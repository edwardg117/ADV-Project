/*
What this needs to do:
    - Place scripted blocks containing the right info on the floor where the player clicks
    - Register points in-between entry/exits
    - Edit nodes
    - Have an NPC to walk newly created paths
    - 

Modes:
    1. Creating Nodes
        1. Pathfinding nodes ("Road Nodes")
        2. Entry/exit nodes ("Locations")
        3. City entry/exit nodes ("Locations" when shift right clicking)
    2. Editing Nodes ("Editing")
    3. Analysis
        1. Have npc walk along created route
*/

var NpcAPI = Java.type("noppes.npcs.api.NpcAPI").Instance();
var File = Java.type("java.io.File");
var Files = Java.type("java.nio.file.Files");
var CHARSET_UTF_8 = Java.type("java.nio.charset.StandardCharsets").UTF_8;

var modeInfo = { // Descriptions for what each mode does, there's probably a better way
    "None":"Used to aid creation of rode network.",
    "Locations":"Creates locations where clicked. Shift + Left Click to place a city entry/exit node.",
    "Road Nodes":"Used to create a path between two locations. Shift + Left Click to place and intersection.",
    "Editing":"Edit existing nodes.",
    "Analysis":"Debug the roads you have placed down."
};
var defaultRegistry = {
    "Info":
    {
        "Version": 2,
        "World": "World Name",
        "NumLocations": 0,
        "NumGates": 0,
        "NumNodes": 0,
        "LockedBy": "",
        "Desc": "This was generated by RoadMaker Helper, you can change this line if you want."
    },
    "Cities":
    {
        "World":
        {
            "Locations":{},
            "Gates":{}
        }
    },
    "Nodes":
    {

    }
};
var defaultSettings = {
    "allowBacktrack": false, // Allow travel in two directions
    "mode": "None",
    "lockRegistry": true, // TODO Prevent race-condition by only allowing 1 editor at a time
    "autoUpdateFile": true // Should the saved file be updated upon every node's creation?
};

var guiComponentList = [ // NodeType_TypeName eg L_FName is Location_TextFieldName 
    "L_Title", // Location placing GUI
    "L_FName",
    "L_LName",
    "L_FCity",
    "L_LCity",
    "L_SCityList",
    "L_LLocation",
    "L_LCords",
    "L_BCancel",
    "L_BSave",

    "G_LTitle", // Gate placing GUI
    "G_LCity",
    "G_FCity",
    "G_SCityList",
    "G_LType",
    "G_BChangeType",
    "G_LLocation",
    "G_LCords",
    "G_BCancel",
    "G_BSave",

    "S_LTitle", // Settungs menu GUI
    "S_LBacktrack",
    "S_BBacktrack",
    "S_LRegistryLock",
    "S_BRegistryLock",
    "S_LAutoSave",
    "S_BAutosave",
    "S_BSaveNow",
    "S_LFileOps",
    "S_BOverwriteRegistry",
    "S_BImportMapData",
    "S_BClearRegistry",
    "S_LOther",
    "S_BClearPrevNode",
    "S_BResetSettings",
    "S_BClose",
    "S_LMode",
    "S_SModeList",
    "S_BConfirm",
    "S_BCancel",
    "S_ClearRegistryConfirmation",
    "S_OverwriteRegistryConfirmation",

    "E_LTitle", // Editing menu GUI
    "E_LSubtitle",
    "E_LName",
    "E_FName",
    "E_LCity",
    "E_FCity",
    "E_SCityList",
    "E_LLocation",
    "E_LCords",
    "E_BEditNeighbours",//
    "E_BDeleteNode",//
    "E_BClose",//
    "E_BSave",//
    "E_BConfirm",
    "E_BCancel",//
    "E_DeleteNodeConfirmation",
    "E_DeleteNeighbourConfirmation",

    "EN_LNeighbours", // Editing neighbours GUI
    "EN_LInfo",
    "EN_SNeighbourList",
    "EN_LNeighbourLocation",
    "EN_LNeighbourCity",
    "EN_LisNeigbour",
    "EN_BRemoveNeighbour",//
    "EN_BClose",//
    "EN_BBack"//
];

var GUI = enumerate(guiComponentList, 1);

function init(event)
{
    // This keeps getting smaller
    var item = event.item;
    
    //if(!item.getStoreddata().get("currentMode")){item.getStoreddata().put("currentMode", "None");} // First init, set mode to none
    if(!item.getStoreddata().get("savedSettings")){item.getStoreddata().put("savedSettings", JSON.stringify(defaultSettings));item.getTempdata().put("settings", JSON.parse(JSON.stringify(defaultSettings)));} //Save settings
    else{item.getTempdata().put("settings", JSON.parse(item.getStoreddata().get("savedSettings")));} // Retreive settings

    var settings = item.getTempdata().get("settings");
    var savedMode = settings.mode; // Retrieve mode name
    updateItemDesc(item, savedMode);
    /*item.setDurabilityShow(false); // Hide durability bar
    item.setColor(12465151); // #BE33FF aka purpleish
    item.setCustomName("Road Maker: §6" + savedMode);
    item.setLore(["§2Current Mode: §6" + savedMode, "§a[shift + left click] air to change mode", modeInfo[savedMode]]);
    item.setStackSize(1); // There should never be two of these but if that happens, you have to choose one*/

    var world = NpcAPI.getIWorld(0);
    if(!world.getTempdata().get("NodeRegistry") && !world.getStoreddata().get("NodeRegistry"))
    {
        var roadsFolder = new File("saves/" + world.getName());
        var registryFile = new File("saves/" + world.getName() + "/Roads/Node Registry.json");
        if(registryFile.exists())
        {
            var fileContents = Files.readAllLines(registryFile.toPath(), CHARSET_UTF_8)[0];
            var registry = JSON.parse(fileContents);
            world.getStoreddata().put("NodeRegistry", fileContents);
            world.getTempdata().put("NodeRegistry", registry)
        }
        else
        {
            roadsFolder.mkdirs();
            registryFile.createNewFile();
            defaultRegistry["Info"]["World"] = world.getName();
            Files.write(registryFile.toPath(), JSON.stringify(defaultRegistry).getBytes());
            world.getTempdata().put("NodeRegistry", defaultRegistry)
            world.getStoreddata().put("NodeRegistry", JSON.stringify(defaultRegistry));
        }
    }
    else{world.getTempdata().put("NodeRegistry", JSON.parse(world.getStoreddata().get("NodeRegistry")));}
}

function updateItemDesc(Item, NewMode)
{
    Item.setDurabilityShow(false); // Hide durability bar
    Item.setColor(12465151); // #BE33FF aka purpleish
    Item.setCustomName("Road Maker: §6" + NewMode);
    Item.setLore(["§2Current Mode: §6" + NewMode, "§a[shift + left click] air to change mode", modeInfo[NewMode]+"\n§6prevNode: §a" + function(val){if(val){return "§2"+val.Name;}else{return "§4Not Set";}}(Item.getTempdata().get("prevNode"))]);
    Item.setStackSize(1); // There should never be two of these but if that happens, you have to choose one
}

/* sadly shift right clicking in cretive opens the item's script interface, moving to attack event
function interact(event)
{
    // 0:air, 1:entity, 2:block
    switch(event.type)
    {
        case 0:
            // Player clicked on the air
            event.player.message("Type is air");
            //event.item.getStoreddata().put("currentMode", "None");
            if(event.player.isSneaking())
            {
                var savedMode = event.item.getStoreddata().get("currentMode");
                var modeList = Object.keys(modeInfo);
                //modeList.indexOf(savedMode) + 1
                if(modeList.indexOf(savedMode) + 1 == modeList.length)
                {
                    var newIndex = 0;
                }
                else
                {
                    var newIndex = modeList.indexOf(savedMode) + 1;
                }
                event.item.getStoreddata().put("currentMode", modeList[newIndex]);
                savedMode = event.item.getStoreddata().get("currentMode");
                event.item.setCustomName("Road Maker: §6" + savedMode);
                event.item.setLore(["§2Current Mode: §6" + savedMode, "§a[shift + right click] to change mode", modeInfo[savedMode]]);
            }
            //event.setCanceled(true); no work ;(
            break;
        case 1:
            // Player clicked on an entity
            event.player.message("Type is entity");
            break;
        case 2:
            // Player clicked on a block
            event.player.message("Type is block");
            var pos = event.target.getPos();
            var newBlock = event.player.world.getBlock(pos.getX(), pos.getY() + 1, pos.getZ());
            //newBlock.setBlock("minecraft:glass");
            newBlock.setBlock("customnpcs:npcscripted");
            newBlock = event.player.world.getBlock(pos.getX(), pos.getY() + 1, pos.getZ());
            //event.player.message(newBlock.getTileEntityNBT().getCompound("Scripts").getKeys()); fail

            newBlock.executeCommand​('blockdata ~ ~ ~ {Scripts:[{Script:"function init(event){event.block.setModel(\"minecraft:glass\");}",Console:[],ScriptList:[]}]}');

            break;
    }
}
*/

function attack(event)
{
    // 0:air, 1:entity, 2:block
    switch(event.type)
    {
        case 0:
            // Player clicked on the air
            // Only change mode if the player is sneaking
            if(event.player.isSneaking())
            {
                var settings = event.item.getTempdata().get("settings");
                var savedMode = settings.mode; // Retrieve mode name
                var modeList = Object.keys(modeInfo); // Get an ordered list of all modes
                // Find the index of the current mode and move to the next. If it is the last element, go back to the first
                if(modeList.indexOf(savedMode) + 1 == modeList.length){var newIndex = 0;}
                else{var newIndex = modeList.indexOf(savedMode) + 1;}
                
                settings.mode = modeList[newIndex];
                event.item.getTempdata().put("settings", settings); // Save new mode
                event.item.getStoreddata().put("savedSettings", JSON.stringify(settings));
                updateItemDesc(event.item, settings.mode);
                // Remove analysis stuff
                if(event.item.getStoreddata().get("AnalysisSelectedNode"))
                {
                    var npcList = event.player.world.getNearbyEntities(event.player.getPos(), 34, 2);
                    for(var i = 0; i<npcList.length; i++)
                    {
                        if(npcList[i].hasTag("RoadsAnalysisWalker")){npcList[i].despawn();}
                    }
                }
                event.item.getStoreddata().put("AnalysisSelectedNode", "");
            }
            else{openSettingsGUI(event, event.item);}
            break;
        case 1:
            // Player clicked on an entity
            // TODO make this interact with the npc somehow
            event.player.message("That is an entity");
            break;
        case 2:
            // Player clicked on a block
            var pos = event.target.getPos().add(0,1,0);
            var currentMode = event.item.getTempdata().get("settings")["mode"];

            if(currentMode == "None")
            {
                event.player.message("No mode set, doing nothing");
            }
            else if(currentMode == "Locations")
            { // Placing location or city entry/exit
                if(!event.player.isSneaking())
                { // Player is placing a location block
                    openLocationGUI(event, pos);
                }
                else
                { // Player is placing a city entry/exit block
                    openGateGUI(event, pos);
                }
            }
            else if(currentMode == "Road Nodes") // Placing node or intersection
            {
                var block = event.player.world.getBlock(pos.getX(), pos.getY()-1, pos.getZ());
                if(block.getStoreddata().get("about"))
                {
                    // Block is a scripted block, possibly made with this script. Check type
                    var blockInfo = JSON.parse(block.getStoreddata().get("about"));
                    if(blockInfo.hasOwnProperty("Type"))
                    {
                        var blockType = blockInfo["Type"];
                        if(blockType == "Node" || blockType == "Location" || blockType == "Gate")
                        {
                            // Is part of the road network
                            // If no previous node: Set as previous node
                            // Else if previous node, set as a neighbour and then set to the previous node
                            var prevNode = event.item.getTempdata().get("prevNode");
                            if(prevNode != null && prevNode["Name"] != blockInfo["Name"])
                            {
                                // There was a previous node and this is not it
                                // Set this node as a neighbour to the previous node
                                // Then set this node as the previous node
                                var registry = event.player.world.getTempdata().get("NodeRegistry"); // Get node registry
                                var settings = event.item.getTempdata().get("settings");
                                // Setting node as neighbour
                                updateRefsAndNeighbours(event.player, registry, settings, prevNode, blockInfo, block.getPos());
                                // This is now the previous Node
                                event.item.getTempdata().put("prevNode", blockInfo);
                                event.player.message("Set Node " + blockInfo["Name"] + " as a neighbour of " + prevNode["Name"]);
                            }
                            else if(prevNode != null && prevNode["Name"] == blockInfo["Name"])
                            {
                                // There was a previous node and, it itself, has been clicked
                                // Tell the player to click something else
                                event.player.message("This Node is already set as the previous node, place a new Node or select an existing node to add a path from this Node.");
                            }
                            else
                            {
                                // There is no previous node, this shouldn't happen unless the player relogs
                                // Set this node as previous node
                                event.item.getTempdata().put("prevNode", blockInfo);
                                event.player.message("Set " + JSON.stringify(blockInfo) + " as previous node");
                            }
                            updateItemDesc(event.item, currentMode);
                        }else{event.player.message("No matching type for scripted block");if(event.player.isSneaking()){placeBlock(event.player, pos, "Intersection");}else{placeBlock(event.player, pos, "Node");}}

                    }else{event.player.message("No Type for scripted block");if(event.player.isSneaking()){placeBlock(event.player, pos, "Intersection");}else{placeBlock(event.player, pos, "Node");}}
                }else{event.player.message("No about for scripted block");if(event.player.isSneaking()){placeBlock(event.player, pos, "Intersection");}else{placeBlock(event.player, pos, "Node");}}
            }
            else if(currentMode == "Editing")
            {
                openEditGUI(event, pos.subtract(0,1,0));
            }
            else if(currentMode == "Analysis")
            {
                analysisMode(event, pos.subtract(0,1,0));
            }
            else
            {
                event.player.message("You are in the darkest timeline and evil Abed has stolen this mode!");
            }

            
            break;
        default:
            event.player.message("Unexpected event type! Expected range 0-2 but got " + event.type);
    }
    event.setCanceled(true);
}

function placeBlock(Player, Pos, Type, Gui)
{
    Gui = Gui || null;
    // Set appropriate values
    var registry = Player.world.getTempdata().get("NodeRegistry"); // Get node registry
    var tool = Player.getMainhandItem();
    var settings = tool.getTempdata().get("settings");
    // TODO Update scripts here
    if(Type === "Node") 
    {
        // Regular node
        var nodeType = Type;
        var colour = 0;
        var City = null;
        var nodeInfo = {"isIntersection":false,"Pos":[Pos.getX(),Pos.getY(),Pos.getZ()],"Neighbours":[],"Refs":[]};
        registry["Info"]["NumNodes"] ++; // Incrememnt number of nodes
        var nodeName = "n" + (registry["Info"]["NumNodes"]); // Node name is "n" with the number of nodes appended to it
        var stringInfo = JSON.stringify(nodeInfo).replace(/"/g, "" ).replace(/ /g, "").replace(/\n/g, "");
        var script = 'ScriptLanguage:"ECMAScript",ScriptEnabled:1b,Scripts:[{Script:"//' + stringInfo + '",Console:[],ScriptList:[]}]';
    }
    else if(Type === "Intersection")
    { // Intersection node
        var nodeType = "Node";
        var colour = 3;
        var City = null;
        var nodeInfo = {"isIntersection":true,"Pos":[Pos.getX(),Pos.getY(),Pos.getZ()],"Neighbours":[],"Refs":[]};
        registry["Info"]["NumNodes"] ++; // Incrememnt number of nodes
        var nodeName = "n" + (registry["Info"]["NumNodes"]); // Node name is "n" with the number of nodes appended to it
        var stringInfo = JSON.stringify(nodeInfo).replace(/"/g, "" ).replace(/ /g, "").replace(/\n/g, "");
        var script = 'ScriptLanguage:"ECMAScript",ScriptEnabled:1b,Scripts:[{Script:"//' + stringInfo + '",Console:[],ScriptList:[]}]';
    }
    else if(Type === "Location")
    {// Location block
        var nodeType = Type;
        var colour = 1;
        var Name = Gui.getComponent(GUI.L_FName).getText();
        var City = Gui.getComponent(GUI.L_FCity).getText();
        var nodeInfo = {"Pos":[Pos.getX(),Pos.getY(),Pos.getZ()],"Neighbours":[],"Refs":[],"City":City,"Name":Name};
        var nodeName = Name;
        registry["Info"]["NumLocations"] ++; // Incrememnt number of locations
        var stringInfo = JSON.stringify(nodeInfo).replace(/"/g, "" ).replace(/ /g, "").replace(/\n/g, "");
        var script = 'ScriptLanguage:"ECMAScript",ScriptEnabled:1b,Scripts:[{Script:"//' + stringInfo + '",Console:[],ScriptList:[]}]';
    }
    else if(Type === "Gate")
    { // Gate node
        var nodeType = Type;
        var colour = 5;
        var City = Gui.getComponent(GUI.G_FCity).getText();
        var gateType = Gui.getComponent(GUI.G_BChangeType).getLabel();
        registry["Info"]["NumGates"] ++; // Incrememnt number of gates
        var nodeName = "G" + (registry["Info"]["NumGates"]); // Gate name is "G" with the number of gates appended to it
        var nodeInfo = {"Type":gateType,"Pos":[Pos.getX(),Pos.getY(),Pos.getZ()],"Neighbours":[],"Refs":[],"City":City};
        var stringInfo = JSON.stringify(nodeInfo).replace(/"/g, "" ).replace(/ /g, "").replace(/\n/g, "");
        var script = 'ScriptLanguage:"ECMAScript",ScriptEnabled:1b,Scripts:[{Script:"//' + stringInfo + '",Console:[],ScriptList:[]}]';
    }
    else
    {
        log("[ERR] placeBlock failed! Type was not 'Node', 'Intersection', 'Location' or 'Gate'. Was: '"+Type+"'");
        Player.message("[ERR] placeBlock failed! Type was not 'Node', 'Intersection', 'Location' or 'Gate'. Was: '"+Type+"'");
        return false;
    }
    
    // Create block
    var newBlock = Player.world.getBlock(Pos.getX(), Pos.getY(), Pos.getZ());
    newBlock.setBlock("customnpcs:npcscripted");
    newBlock = Player.world.getBlock(Pos.getX(), Pos.getY(), Pos.getZ());
    newBlock.setModel(newBlock.world.createItem("minecraft:stained_glass", colour, 1));
    newBlock.setIsPassible(true);
    newBlock.getTextPlane().setText(nodeName);
    newBlock.getTextPlane().setScale(2);
    newBlock.getTextPlane2().setRotationY(0);
    newBlock.getTextPlane2().setText(nodeName);
    newBlock.getTextPlane2().setScale(2);
    newBlock.getTextPlane2().setRotationY(90);
    newBlock.getTextPlane3().setText(nodeName);
    newBlock.getTextPlane3().setScale(2);
    newBlock.getTextPlane3().setRotationY(180);
    newBlock.getTextPlane4().setText(nodeName);
    newBlock.getTextPlane4().setScale(2);
    newBlock.getTextPlane4().setRotationY(270);
    // Apply Script
    newBlock.executeCommand​('blockdata ~ ~ ~ {' + script + '}');
    newBlock.getStoreddata().put("about",JSON.stringify({"Type":nodeType, "Name":nodeName, "City":City})); // Make it easier to identify itself later
    Player.message("Placed node: " + newBlock.getStoreddata().get("about"));// nodeName

    // Register node
    if(nodeType === "Node"){registry["Nodes"][nodeName] = nodeInfo;} // Add nodeInfo under the name of the node
    else if(nodeType === "Location"){
        if(!registry.Cities.hasOwnProperty(City)){registry["Cities"][City] = {"Locations":{},"Gates":{}};} // Adds the City if it doesn't exist
        registry["Cities"][City]["Locations"][nodeName] = nodeInfo;} // Add nodeInfo under the name of the location
    else{if(!registry.Cities.hasOwnProperty(City)){registry["Cities"][City] = {"Locations":{},"Gates":{}};}registry["Cities"][City]["Gates"][nodeName] = nodeInfo;} // Add nodeInfo under the name of the gate
    
    // Update previous node and this one if backtracking
    var prevNode = tool.getTempdata().get("prevNode");
    // Only doing this for nodes, this will get called later when the node is linked to the Location or Gate
    if(prevNode && nodeType == "Node"){updateRefsAndNeighbours(Player, registry, settings, prevNode, {"Type":nodeType, "Name":nodeName, "City":City}, Pos);}

    // This is now the previous Node
    var about = {"Type":nodeType, "Name":nodeName, "City":City};
    tool.getTempdata().put("prevNode",about);
    
    // Save registry
    newBlock.world.getStoreddata().put("NodeRegistry", JSON.stringify(registry)); // Save the registry to storeddata

    // Save to file?
    if(settings.autoUpdateFile)
    {
        var registryFile = new File("saves/" + Player.world.getName() + "/Roads/Node Registry.json");
        Files.write(registryFile.toPath(), JSON.stringify(registry).getBytes());
    }

    updateItemDesc(tool, settings.mode);
    return newBlock;
}
function updateRefsAndNeighbours(Player, registry, settings, prevNode, nextNode, nextNodePos)
{
    // Check to see if it's already neighbours
    if(!isAlreadyNeighbour(registry, prevNode, nextNode))
    {
        // Add node as a refrence
        // Update new node first
        if(nextNode.Type == "Node"){registry["Nodes"][nextNode.Name]["Refs"].push([prevNode.Name, prevNode.City]);} // [Referenced by, City of node]
        else if(nextNode.Type == "Location"){registry["Cities"][nextNode.City]["Locations"][nextNode.Name]["Refs"].push([prevNode.Name, prevNode.City]);}
        else{registry["Cities"][nextNode.City]["Gates"][nextNode.Name]["Refs"].push([prevNode.Name, prevNode.City]);}
        // Find distance
        if(prevNode.Type == "Node"){var pPos = registry["Nodes"][prevNode.Name]["Pos"];}
        else if(prevNode.Type == "Location"){var pPos = registry["Cities"][prevNode.City]["Locations"][prevNode.Name]["Pos"];}
        else{var pPos = registry["Cities"][prevNode.City]["Gates"][prevNode.Name]["Pos"];}
        var neighbourPos = Player.world.getBlock(pPos[0], pPos[1], pPos[2]).getPos();
        var distance = nextNodePos.distanceTo(neighbourPos);
        // Update neighbour in previous node
        if(prevNode.Type == "Node"){registry["Nodes"][prevNode.Name]["Neighbours"].push([nextNode.Name, distance, nextNode.City]);}
        else if(prevNode.Type == "Location"){registry["Cities"][prevNode.City]["Locations"][prevNode.Name]["Neighbours"].push([nextNode.Name, distance, nextNode.City]);}
        else{registry["Cities"][prevNode.City]["Gates"][prevNode.Name]["Neighbours"].push([nextNode.Name, distance, nextNode.City]);}
    }
    if(settings.allowBacktrack && !isAlreadyNeighbour(registry, nextNode, prevNode))
    { // The previous node should be a neighbour of this node too
        // Update previous node first
        Player.message("Backtracking enabled")
        if(prevNode.Type == "Node"){registry["Nodes"][prevNode.Name]["Refs"].push([nextNode.Name, nextNode.City]);}
        else if(prevNode.Type == "Location"){registry["Cities"][prevNode.City]["Locations"][prevNode.Name]["Refs"].push([nextNode.Name, nextNode.City]);}
        else{registry["Cities"][prevNode.City]["Gates"][prevNode.Name]["Refs"].push([nextNode.Name, nextNode.City]);}
        // Update new node now
        if(nextNode.Type == "Node"){registry["Nodes"][nextNode.Name]["Neighbours"].push([prevNode.Name, distance, prevNode.City]);}
        else if(nextNode.Type == "Location"){registry["Cities"][nextNode.City]["Locations"][nextNode.Name]["Neighbours"].push([prevNode.Name, distance, prevNode.City]);}
        else{registry["Cities"][nextNode.City]["Gates"][nextNode.Name]["Neighbours"].push([prevNode.Name, distance, prevNode.City]);}
    }
    return registry;
}

function isAlreadyNeighbour(registry, fromNode, toNode) // to prevent duplicate neighbours
{
    var isNeighbour = false;
    if(toNode.Type == "Node"){var neighbours = registry["Nodes"][toNode.Name]["Refs"];}
    else if(toNode.Type == "Location"){var neighbours = registry["Cities"][toNode.City]["Locations"][toNode.Name]["Refs"];}
    else{var neighbours = registry["Cities"][toNode.City]["Gates"][toNode.Name]["Refs"];}
    for(var i = 0; i < neighbours.length; i++)
    {
        if(neighbours[i][0] == fromNode.Name && neighbours[i][1] == fromNode.City)
        {
            isNeighbour = true;
            break;
        }
    }
    return isNeighbour;
}

'Scripts:[{Script:"var test = true;",Console:[],ScriptList:[]}]'

function openLocationGUI(event, Pos) // Places Locations and Gates
{
    /* 
    If player is not sneaking: Place Location
        Open GUI
    Else player is sneaking: Place Gate
        Open GUI
    */
   var pauseGame = true;

    var gui = event.API.createCustomGui(0, 256, 256, pauseGame);
    gui.setBackgroundTexture("customnpcs:textures/gui/bgfilled.png");
    gui.addLabel(GUI.L_Title, "Location", 106, 15, 45, 1, 16747795); // 16747795 = #FF8D13 = orange

    gui.addTextField(GUI.L_FName, 40, 40, 100, 10);
    gui.addLabel(GUI.L_LName, "Name", 10, 40, 30, 10);
    gui.addTextField(GUI.L_FCity, 40, 60, 100, 10);
    gui.addLabel(GUI.L_LCity, "City", 10, 60, 30, 10);

    //var list = ["Option 1", "Option 2", "Option 3", "Option 4", "Option 5", "Option 6", "Option 7", "Option 8", "Option 9", "Option 10", "Option 11", "Option 12", "Option 13", "Option 14", "Option 15"];
    var registry = event.player.world.getTempdata().get("NodeRegistry"); // Get node registry
    var cityList = Object.keys(registry["Cities"]);
    gui.addScroll(GUI.L_SCityList, 40, 80, 100, 50, cityList);
    
    gui.addLabel(GUI.L_LLocation, "Location", 5, 150, 45, 10);
    gui.addLabel(GUI.L_LCords, "X:"+Pos.getX()+" Y:"+Pos.getY()+" Z:"+Pos.getZ(), 50, 150, 250, 10);
    
    gui.addButton(GUI.L_BCancel,"Cancel", 30, 200, 50, 20);
    gui.addButton(GUI.L_BSave,"Save", 150, 200, 50, 20);

    event.player.showCustomGui(gui);
}

function openGateGUI(event, Pos)
{
    var pauseGame = true;

    var gui = event.API.createCustomGui(0, 256, 256, pauseGame);
    gui.setBackgroundTexture("customnpcs:textures/gui/bgfilled.png");
    gui.addLabel(GUI.G_LTitle, "Gate", 106, 15, 45, 1, 1357312); // 1357312 = #14b600 = green

    gui.addTextField(GUI.G_FCity, 40, 40, 100, 10);
    gui.addLabel(GUI.G_LCity, "City", 10, 40, 30, 10);
    var registry = event.player.world.getTempdata().get("NodeRegistry"); // Get node registry
    var cityList = Object.keys(registry["Cities"]);
    gui.addScroll(GUI.G_SCityList, 40, 50, 100, 50, cityList);

    gui.addLabel(GUI.G_LType, "Type", 10, 110, 100, 10);
    gui.addButton(GUI.G_BChangeType,"Entry", 60, 110, 50, 20);

    gui.addLabel(GUI.G_LLocation, "Location", 5, 150, 45, 10);
    gui.addLabel(GUI.G_LCords, "X:"+Pos.getX()+" Y:"+Pos.getY()+" Z:"+Pos.getZ(), 50, 150, 250, 10);

    gui.addButton(GUI.G_BCancel,"Cancel", 30, 200, 50, 20);
    gui.addButton(GUI.G_BSave,"Save", 150, 200, 50, 20);

    event.player.showCustomGui(gui);
}

function openSettingsGUI(event, tool)
{
    var settings = tool.getTempdata().get("settings");
    var pauseGame = true;

    var gui = event.API.createCustomGui(0, 256, 256, pauseGame);
    gui.setBackgroundTexture("customnpcs:textures/gui/bgfilled.png");
    gui.addLabel(GUI.S_LTitle, "Settings", 106, 15, 45, 1);

    gui.addLabel(GUI.S_LBacktrack, "Allow Backtracking", 10, 40, 70, 20);
    gui.addButton(GUI.S_BBacktrack, function(val){if(val){return "§2"+val}else{return "§4"+val}}(settings.allowBacktrack), 80 ,40, 50, 20).setHoverText("Automatically allow travel in both directions.");
    gui.addLabel(GUI.S_LRegistryLock, "Lock Registry", 10, 60, 70, 20);
    gui.addButton(GUI.S_BRegistryLock, function(val){if(val){return "§2"+val}else{return "§4"+val}}(settings.lockRegistry), 80 ,60, 50, 20).setHoverText("Prevents a race condition\nby only allowing one\nplayer at a time to edit.");
    gui.addLabel(GUI.S_LAutoSave, "Automatically Write to File", 10, 80, 70, 20);
    gui.addButton(GUI.S_BAutosave, function(val){if(val){return "§2"+val}else{return "§4"+val}}(settings.autoUpdateFile), 80 ,80, 50, 20).setHoverText("Should the registry file be updated after every new node?\nDisable for larger networks and save manually.");
    gui.addLabel(GUI.S_LMode, "Mode", 40, 105, 70, 20);
    var modeList = Object.keys(modeInfo);
    gui.addScroll(GUI.S_SModeList, 10, 120, 100, 80, modeList).setDefaultSelection(modeList.indexOf(settings.mode));

    gui.addLabel(GUI.S_LFileOps, "File Operations", 170, 40, 70, 20);
    gui.addButton(GUI.S_BSaveNow, "Write Now", 136, 60, 54, 20).setHoverText("All data is saved in game.\nThis button saves the data to the external file for processing.");
    gui.addButton(GUI.S_BImportMapData, "Import Map", 136, 80, 54, 20).setHoverText("Import Mapped Paths from file");
    gui.addButton(GUI.S_BOverwriteRegistry, "Overwrite", 190, 60, 54, 20).setHoverText("Import the registry file and overwrite the in-game registry");
    gui.addButton(GUI.S_BClearRegistry, "Purge", 190, 80, 54, 20).setHoverText("Clears the registry, removing all Locations, Gates and Nodes\n(Wipes all registry data)");

    gui.addLabel(GUI.S_LOther, "Other", 170, 105, 70, 20);
    gui.addButton(GUI.S_BClearPrevNode, "Clear prevNode", 140, 120, 100, 20).setHoverText("Removes prevNode so you can set it again to another node.");
    gui.addButton(GUI.S_BResetSettings, "Reset Settings", 140, 140, 100, 20).setHoverText("Resets all settings to default, does not delete the registry.");

    gui.addButton(GUI.S_BClose, "Close", 10, 210, 50, 20);

    event.player.showCustomGui(gui);
}

function openEditGUI(event, Pos) // Manipulation of existing nodes // TODO Editing mode
{
    var tool = event.player.getMainhandItem();
    var selectedNode = event.player.world.getBlock(Pos.getX(), Pos.getY(), Pos.getZ());
    var aboutNode = JSON.parse(selectedNode.getStoreddata().get("about"));
    if(!aboutNode){return null;}
    //event.player.message("Selected: " + aboutNode.Name);
    // Find node in registry
    var registry = event.player.world.getTempdata().get("NodeRegistry");
    if(aboutNode.City)
    {
        if(aboutNode.Type === "Location"){var nodeData = registry["Cities"][aboutNode.City]["Locations"][aboutNode.Name];}
        else if(aboutNode.Type === "Gate"){var nodeData = registry["Cities"][aboutNode.City]["Gates"][aboutNode.Name];}
        else{event.player.message("Node has City but isn't a Location or Gate!!");}
    }
    else{var nodeData = registry["Nodes"][aboutNode.Name];}

    //event.player.message("Neighbours: " + JSON.stringify(nodeData.Neighbours));

    var pauseGame = true;
    var gui = event.API.createCustomGui(0, 256, 256, pauseGame);
    gui.setBackgroundTexture("customnpcs:textures/gui/bgfilled.png");

    gui.addLabel(GUI.E_LTitle, "Editing: §6" + aboutNode.Name, 10, 10, 240, 1);
    gui.addLabel(GUI.E_LSubtitle, "Type: " + aboutNode.Type, 10, 20, 240, 1);

    gui.addLabel(GUI.ELName, "Name", 10, 30, 30, 10);
    gui.addTextField(GUI.E_FName, 40, 30, 100, 10).setText(aboutNode.Name);
    if(aboutNode.Type == "Node")
    {
        gui.addLabel(GUI.E_LCity, "Type", 10, 50, 30, 10);
        if(nodeData.isIntersection){gui.addLabel(GUI.E_FCity, "Intersection", 40, 50, 30, 10);}
        else{gui.addLabel(GUI.E_FCity, "Node", 40, 50, 30, 10);}
    }
    else
    {
        gui.addLabel(GUI.E_LCity, "City", 10, 50, 30, 10);
        gui.addTextField(GUI.E_FCity, 40, 50, 100, 10).setText(aboutNode.City);
        var registry = event.player.world.getTempdata().get("NodeRegistry"); // Get node registry
        var cityList = Object.keys(registry["Cities"]);
        gui.addScroll(GUI.E_SCityList, 40, 60, 100, 50, cityList);
    }
    gui.addLabel(GUI.E_LLocation, "Location", 5, 120, 45, 10);
    gui.addLabel(GUI.E_LCords, "X:"+Pos.getX()+" Y:"+Pos.getY()+" Z:"+Pos.getZ(), 50, 120, 250, 10);

    gui.addButton(GUI.E_BEditNeighbours, "Edit Neighbours", 20, 140, 100, 20);
    gui.addButton(GUI.E_BDeleteNode, "Delete Node", 136, 140, 100, 20);

    gui.addButton(GUI.E_BCancel,"Cancel", 30, 200, 50, 20);
    gui.addButton(GUI.E_BSave,"Save", 150, 200, 50, 20);

    tool.getTempdata().put("Focussed Node", aboutNode);

    event.player.showCustomGui(gui);

}

function openEditNeighbourGUI(event, Pos) // TODO Edit Neighbours
{
    var selectedNode = event.player.world.getBlock(Pos.getX(), Pos.getY(), Pos.getZ());
    var aboutNode = JSON.parse(selectedNode.getStoreddata().get("about"));
    if(!aboutNode){return null;}
    //event.player.message("Selected: " + aboutNode.Name);
    // Find node in registry
    var registry = event.player.world.getTempdata().get("NodeRegistry");
    if(aboutNode.City)
    {
        if(aboutNode.Type === "Location"){var nodeData = registry["Cities"][aboutNode.City]["Locations"][aboutNode.Name];}
        else if(aboutNode.Type === "Gate"){var nodeData = registry["Cities"][aboutNode.City]["Gates"][aboutNode.Name];}
        else{event.player.message("Node has City but isn't a Location or Gate!!");}
    }
    else{var nodeData = registry["Nodes"][aboutNode.Name];}

    //event.player.message("Neighbours: " + JSON.stringify(nodeData.Neighbours));

    var pauseGame = true;
    var gui = event.API.createCustomGui(0, 256, 256, pauseGame);
    gui.setBackgroundTexture("customnpcs:textures/gui/bgfilled.png");

    gui.addLabel(GUI.E_LTitle, "Editing: §6" + aboutNode.Name, 10, 10, 240, 1);
    gui.addLabel(GUI.E_LSubtitle, "Type: " + aboutNode.Type, 10, 20, 240, 1);

    gui.addLabel(GUI.EN_LNeighbours, "Neighbours", 30, 40, 60, 10);
    gui.addLabel(GUI.EN_LInfo, "Info", 160, 40, 30, 10);
    
    var neighbourList = [];
    for(var i = 0; i < nodeData.Neighbours.length; i++)
    {
        neighbourList.push(nodeData.Neighbours[i][0]);
    }
    gui.addScroll(GUI.EN_SNeighbourList, 10, 60, 100, 50, neighbourList);

    gui.addButton(GUI.EN_BClose,"Close", 30, 200, 50, 20);
    gui.addButton(GUI.EN_BBack,"Back", 150, 200, 50, 20);

    event.player.showCustomGui(gui);
}

function analysisMode(event, Pos) // Help debug issues
{
    if(event.item.getStoreddata().get("AnalysisSelectedNode"))
    {
        var npcList = event.player.world.getNearbyEntities(Pos, 34, 2);
        for(var i = 0; i<npcList.length; i++)
        {
            if(npcList[i].hasTag("RoadsAnalysisWalker")){npcList[i].despawn();}
        }
    }
    var selectedNode = event.player.world.getBlock(Pos.getX(), Pos.getY(), Pos.getZ());
    var aboutNode = JSON.parse(selectedNode.getStoreddata().get("about"));
    if(!aboutNode){return null;}
    event.item.getStoreddata().put("AnalysisSelectedNode", aboutNode.Name);
    event.player.message("Selected: " + aboutNode.Name);
    // Find node in registry
    var registry = event.player.world.getTempdata().get("NodeRegistry");
    if(aboutNode.City)
    {
        if(aboutNode.Type === "Location"){var nodeData = registry["Cities"][aboutNode.City]["Locations"][aboutNode.Name];}
        else if(about.Type === "Gate"){var nodeData = registry["Cities"][aboutNode.City]["Gates"][aboutNode.Name];}
        else{event.player.message("Node has City but isn't a Location or Gate!!");}
    }
    else{var nodeData = registry["Nodes"][aboutNode.Name];}

    event.player.message("Neighbours: " + JSON.stringify(nodeData.Neighbours));
    event.player.message("Refrenced By: " + JSON.stringify(nodeData.Refs));

    // Walkers
    for(var i = 0; i < nodeData.Neighbours.length; i++)
    {
        var neighbourName = nodeData.Neighbours[i][0];
        if(/^n\d*$/.test(neighbourName))
        { // It's a node
            var neighbourData = registry.Nodes[neighbourName];
        }
        else if(/^G\d*$/.test(neighbourName))
        { // Is gate
            var Cities = Object.keys(registry.Cities);
            for(var i=0; i < Cities.length; i++)
            {
                if(registry.Cities[Cities[i]]["Gates"].hasOwnProperty(neighbourName))
                {
                    var neighbourData = registry.Cities[Cities[i]]["Gates"][neighbourName];
                    break;
                }
            }
        }
        else
        { // Is location
            var Cities = Object.keys(registry.Cities);
            for(var i=0; i < Cities.length; i++)
            {
                if(registry.Cities[Cities[i]]["Locations"].hasOwnProperty(neighbourName))
                {
                    var neighbourData = registry.Cities[Cities[i]]["Locations"][neighbourName];
                    break;
                }
            }
        }

        var walkerNPC = NpcAPI.createNPC(event.player.world.getMCWorld());
        walkerNPC.setHome(Pos.getX(), Pos.getY(), Pos.getZ());
        var NPCSctipt = "var start = ["+Pos.getX()+","+Pos.getY()+","+Pos.getZ()+"];var end = ["+neighbourData.Pos[0]+","+neighbourData.Pos[1]+","+neighbourData.Pos[2]+'];function tick(event){if(!event.npc.isNavigating()){event.npc.executeCommand(\\"tp @e[r=1,type=!player,tag='+walkerNPC.getUUID()+'] \\" + (start[0]+0.5) + \\" \\" + start[1] + \\" \\" + (start[2]+0.5));event.npc.navigateTo(end[0],end[1],end[2],1);}}';
        var script = 'ScriptLanguage:"ECMAScript",ScriptEnabled:1b,Scripts:[{Script:"' + NPCSctipt + '",Console:[],ScriptList:[]}]';
        
        walkerNPC.display.setName("§6"+ neighbourName);
        walkerNPC.display.setSize(2);
        walkerNPC.display.setTint(12465151);
        
        walkerNPC.ai.setDoorInteract(1);
        walkerNPC.ai.setReturnsHome(false);
        walkerNPC.ai.setRetaliateType(3);
        walkerNPC.ai.setStopOnInteract(false);
        
        walkerNPC.inventory.setArmor(0, walkerNPC.world.createItem("minecraft:magenta_glazed_terracotta", 0, 1));
        walkerNPC.setPos(Pos);
        walkerNPC.addTag("RoadsAnalysisWalker");
        walkerNPC.addTag(walkerNPC.getUUID());
        walkerNPC.spawn();
        walkerNPC.executeCommand("entitydata @e[tag="+walkerNPC.getUUID()+"] {"+script+",Silent:1b}");
    }
    for(var i = 0; i < nodeData.Refs.length; i++)
    {
        var neighbourName = nodeData.Refs[i][0];
        if(/^n\d*$/.test(neighbourName))
        { // It's a node
            var neighbourData = registry.Nodes[neighbourName];
        }
        else if(/^G\d*$/.test(neighbourName))
        { // Is gate
            var Cities = Object.keys(registry.Cities);
            for(var i=0; i < Cities.length; i++)
            {
                if(registry.Cities[Cities[i]]["Gates"].hasOwnProperty(neighbourName))
                {
                    var neighbourData = registry.Cities[Cities[i]]["Gates"][neighbourName];
                    break;
                }
            }
        }
        else
        { // Is location
            var Cities = Object.keys(registry.Cities);
            for(var i=0; i < Cities.length; i++)
            {
                if(registry.Cities[Cities[i]]["Locations"].hasOwnProperty(neighbourName))
                {
                    var neighbourData = registry.Cities[Cities[i]]["Locations"][neighbourName];
                    break;
                }
            }
        }
        //+Pos.getX()+","+Pos.getY()+","+Pos.getZ()+
        var walkerNPC = NpcAPI.createNPC(event.player.world.getMCWorld());
        walkerNPC.setHome(neighbourData.Pos[0],neighbourData.Pos[1],neighbourData.Pos[2]);
        var NPCSctipt = "var start = ["+neighbourData.Pos[0]+","+neighbourData.Pos[1]+","+neighbourData.Pos[2]+"];var end = ["+Pos.getX()+","+Pos.getY()+","+Pos.getZ()+'];function tick(event){if(!event.npc.isNavigating()){event.npc.executeCommand(\\"tp @e[r=1,type=!player,tag='+walkerNPC.getUUID()+'] \\" + (start[0]+0.5) + \\" \\" + start[1] + \\" \\" + (start[2]+0.5));event.npc.navigateTo(end[0],end[1],end[2],1);}}';
        var script = 'ScriptLanguage:"ECMAScript",ScriptEnabled:1b,Scripts:[{Script:"' + NPCSctipt + '",Console:[],ScriptList:[]}]';
        
        walkerNPC.display.setName("§6"+ neighbourName);
        walkerNPC.display.setSize(2);
        walkerNPC.display.setTint(12465151);
        
        walkerNPC.ai.setDoorInteract(1);
        walkerNPC.ai.setReturnsHome(false);
        walkerNPC.ai.setRetaliateType(3);
        walkerNPC.ai.setStopOnInteract(false);
        
        walkerNPC.inventory.setArmor(0, walkerNPC.world.createItem("minecraft:magenta_glazed_terracotta", 0, 1));
        walkerNPC.setPosition(neighbourData.Pos[0],neighbourData.Pos[1],neighbourData.Pos[2]);
        walkerNPC.addTag("RoadsAnalysisWalker");
        walkerNPC.addTag(walkerNPC.getUUID());
        walkerNPC.spawn();
        walkerNPC.executeCommand("entitydata @e[tag="+walkerNPC.getUUID()+"] {"+script+",Silent:1b}");
    }
}

function customGuiButton(event)
{
    //event.player.message("test");
    switch(event.buttonId)
    {
        case GUI.L_BCancel:
            event.player.closeGui();
            break;
        case GUI.L_BSave:
            //event.player.message(event.gui.getComponent(GUI.L_FName).getText() + "\n" + event.gui.getComponent(GUI.L_FCity).getText());
            // Need to get the pos
            var posLabelText = event.gui.getComponent(GUI.L_LCords).getText();
            // X = index of X+2:index of Y-1
            // Y = index of Y+2:index of Z-1
            // Z = index of Z+2
            var posX = posLabelText.slice(posLabelText.indexOf("X")+2,posLabelText.indexOf("Y")-1);
            var posY = posLabelText.slice(posLabelText.indexOf("Y")+2,posLabelText.indexOf("Z")-1);
            var posZ = posLabelText.slice(posLabelText.indexOf("Z")+2);

            var pos = event.player.world.getBlock(posX, posY, posZ).getPos();
            var newBlock = placeBlock(event.player, pos, "Location", event.gui);
            
            event.player.closeGui();
            break;
        case GUI.G_BChangeType:
            var button = event.gui.getComponent(GUI.G_BChangeType);
            if(button.getLabel() == "Entry"){button.setLabel("Exit");}
            else{button.setLabel("Entry");}
            //event.gui.updateComponent(button);
            event.gui.update(event.player);
            break;
        case GUI.G_BCancel:
            event.player.closeGui();
            break;
        case GUI.G_BSave:
            //event.player.message("test")
            // Need to get the pos
            var posLabelText = event.gui.getComponent(GUI.G_LCords).getText();
            // X = index of X+2:index of Y-1
            // Y = index of Y+2:index of Z-1
            // Z = index of Z+2
            var posX = posLabelText.slice(posLabelText.indexOf("X")+2,posLabelText.indexOf("Y")-1);
            var posY = posLabelText.slice(posLabelText.indexOf("Y")+2,posLabelText.indexOf("Z")-1);
            var posZ = posLabelText.slice(posLabelText.indexOf("Z")+2);

            var pos = event.player.world.getBlock(posX, posY, posZ).getPos();
            var newBlock = placeBlock(event.player, pos, "Gate", event.gui);
            
            event.player.closeGui();
            break;
        case GUI.S_BBacktrack: // Toggle
            var tool = event.player.getMainhandItem();
            var settings = tool.getTempdata().get("settings");
            if(settings.allowBacktrack){settings.allowBacktrack = false;}
            else{settings.allowBacktrack = true;}
            tool.getStoreddata().put("savedSettings", settings);
            event.gui.getComponent(GUI.S_BBacktrack).setLabel(function(val){if(val){return "§2"+val}else{return "§4"+val}}(settings.allowBacktrack));
            event.gui.update(event.player);
            break;
        case GUI.S_BRegistryLock: // Toggle
            var tool = event.player.getMainhandItem();
            var settings = tool.getTempdata().get("settings");
            if(settings.lockRegistry){settings.lockRegistry = false;}
            else{settings.lockRegistry = true;}
            tool.getStoreddata().put("savedSettings", settings);
            event.gui.getComponent(GUI.S_BRegistryLock).setLabel(function(val){if(val){return "§2"+val}else{return "§4"+val}}(settings.lockRegistry));
            event.gui.update(event.player);
            break;
        case GUI.S_BAutosave: // Toggle
            var tool = event.player.getMainhandItem();
            var settings = tool.getTempdata().get("settings");
            if(settings.autoUpdateFile){settings.autoUpdateFile = false;}
            else{settings.autoUpdateFile = true;}
            tool.getStoreddata().put("savedSettings", settings);
            event.gui.getComponent(GUI.S_BAutosave).setLabel(function(val){if(val){return "§2"+val}else{return "§4"+val}}(settings.autoUpdateFile));
            event.gui.update(event.player);
            break;
        case GUI.S_BSaveNow:
            //var tool = event.player.getMainhandItem();
            var registry = event.player.world.getTempdata().get("NodeRegistry");
            var registryFile = new File("saves/" + event.player.world.getName() + "/Roads/Node Registry.json");
            Files.write(registryFile.toPath(), JSON.stringify(registry).getBytes());
            event.player.message("Saved Registry to external file: saves/" + event.player.world.getName() + "/Roads/Node Registry.json");
            break;
        case GUI.S_BOverwriteRegistry:
            // Should ask for confirmation
            var confirmGui = event.API.createCustomGui(GUI.S_OverwriteRegistryConfirmation, 256, 80, true);
            confirmGui.setBackgroundTexture("customnpcs:textures/gui/bgfilled.png");
            confirmGui.addLabel(GUI.S_LTitle, "ARE YOU SURE?", 90, 15, 150, 10, 16711680);
            confirmGui.addLabel(GUI.S_LRegistryLock, "This action will overwrite all in-game data with data from the external file. The external file will not be erased.", 10, 20, 236, 40);
            confirmGui.addButton(GUI.S_BCancel, "Cancel", 10, 60, 50, 20);
            confirmGui.addButton(GUI.S_BConfirm, "Confirm", 196, 60, 50, 20);
            event.player.showCustomGui(confirmGui);
            break;
        case GUI.S_BImportMapData:
            var pathsFile = new File("saves/" + event.player.world.getName() + "/Roads/Mapped Paths.json");
            var fileContents = Files.readAllLines(pathsFile.toPath(), CHARSET_UTF_8)[0];
            var paths = JSON.parse(fileContents);
            event.player.world.getTempdata().put("MappedPaths", paths);
            event.player.world.getStoreddata().put("MappedPaths", fileContents);
            event.player.message("Done! Mapped Paths imported and ready for use!");
            break;
        case GUI.S_BClearRegistry:
            // Should ask for confirmation
            var confirmGui = event.API.createCustomGui(GUI.S_ClearRegistryConfirmation, 256, 80, true);
            confirmGui.setBackgroundTexture("customnpcs:textures/gui/bgfilled.png");
            confirmGui.addLabel(GUI.S_LTitle, "ARE YOU SURE?", 90, 10, 150, 10, 16711680);
            confirmGui.addLabel(GUI.S_LRegistryLock, "This action will erase all registry data stored in-game. This will not erase any data in the external file or the physical nodes themselves.", 10, 20, 236, 40);
            confirmGui.addButton(GUI.S_BCancel, "Cancel", 10, 60, 50, 20);
            confirmGui.addButton(GUI.S_BConfirm, "Confirm", 196, 60, 50, 20);
            event.player.showCustomGui(confirmGui);
            break;
        case GUI.S_BClearPrevNode:
            var tool = event.player.getMainhandItem();
            tool.getTempdata().put("prevNode", null);
            updateItemDesc(tool, tool.getTempdata().get("settings").mode);
            event.player.message("prevNode cleared!");
            break;
        case GUI.S_BResetSettings:
            var tool = event.player.getMainhandItem();
            var settings = JSON.parse(JSON.stringify(defaultSettings)); // Need a separate object of defaultSettings will be edited :S
            tool.getTempdata().put("settings", settings);
            tool.getStoreddata().put("savedSettings", JSON.stringify(settings));
            event.gui.getComponent(GUI.S_BBacktrack).setLabel(function(val){if(val){return "§2"+val}else{return "§4"+val}}(settings.allowBacktrack));
            event.gui.getComponent(GUI.S_BRegistryLock).setLabel(function(val){if(val){return "§2"+val}else{return "§4"+val}}(settings.lockRegistry));
            event.gui.getComponent(GUI.S_BAutosave).setLabel(function(val){if(val){return "§2"+val}else{return "§4"+val}}(settings.autoUpdateFile));
            event.gui.update(event.player);
            event.player.message("Tool settings reset to default values");
            break;
        case GUI.S_BClose:
            event.player.closeGui();
            break;
        case GUI.S_BCancel:
            openSettingsGUI(event, event.player.getMainhandItem());
            break;
        case GUI.S_BConfirm:
            if(event.gui.getID() === GUI.S_OverwriteRegistryConfirmation) // Overwrite from file
            {
                var registryFile = new File("saves/" + event.player.world.getName() + "/Roads/Node Registry.json");
                var fileContents = Files.readAllLines(registryFile.toPath(), CHARSET_UTF_8)[0];
                var registry = JSON.parse(fileContents);
                event.player.world.getStoreddata().put("NodeRegistry", fileContents);
                event.player.world.getTempdata().put("NodeRegistry", registry);
                event.player.message("Done! Local data overwritten with external data.");
            }
            else if(event.gui.getID() === GUI.S_ClearRegistryConfirmation) // Purge local registry
            {
                event.player.world.getStoreddata().put("NodeRegistry", JSON.stringify(defaultRegistry));
                event.player.world.getTempdata().put("NodeRegistry", JSON.parse(JSON.stringify(defaultRegistry)));
                event.player.message("Done! Local data erased, blocks have not been removed. You should probably manually remove them.");
            }
            else{event.player.message("Somehow you've accidentally used GUI.S_BConfirm for something other than confirming a data overwrite or purge...")}
            openSettingsGUI(event, event.player.getMainhandItem());
            break;
        case GUI.E_BClose:
            event.player.closeGui();
            break;
        case GUI.EN_BClose:
            event.player.closeGui();
            break;
        case GUI.E_BSave:
            var tool = event.player.getMainhandItem();
            var posLabelText = event.gui.getComponent(GUI.E_LCords).getText();
            var aboutNode = tool.getTempdata().get("Focussed Node");
            // X = index of X+2:index of Y-1
            // Y = index of Y+2:index of Z-1
            // Z = index of Z+2
            var posX = posLabelText.slice(posLabelText.indexOf("X")+2,posLabelText.indexOf("Y")-1);
            var posY = posLabelText.slice(posLabelText.indexOf("Y")+2,posLabelText.indexOf("Z")-1);
            var posZ = posLabelText.slice(posLabelText.indexOf("Z")+2);

            var block = event.player.world.getBlock(posX, posY, posZ);
            var pos = block.getPos();
            var madeChanges = false;

            // If Name change
            if(event.gui.getComponent(GUI.E_FName).getText() != aboutNode.Name)
            {
                /* #1 edit neighbour entries first
                    Edit neighbour entries first
                    - For every node that references this one, update the name in it's neighbour entry
                    #2 Edit neighbour refs second
                    - For every neighbour of this node, edit the refs in those nodes

                #3 Change name in registry and about
                    - Create new entry with copied data
                    - Pop old entry
                    - save about into block
                */
               // #1
               var registry = event.player.world.getTempdata().get("NodeRegistry");
               if(aboutNode.Type == "Node")
               {
                    var referencedBy = registry.Nodes[aboutNode.Name].Refs;
               }
               else if(aboutNode.Type == "Location")
               {
                    var referencedBy = registry.Cities[aboutNode.City].Locations[aboutNode.Name].Refs;
               }
               else if(aboutNode.Type == "Gate")
               {
                    var referencedBy = registry.Cities[aboutNode.City].Gates[aboutNode.Name].Refs;
               }
               else
               {
                   event.player.message("Something has gone very wrong, aborting action!");
                   log("[ERR!] Tried to save name for node '" + aboutNode.Name + "' but it had no valid type!");
                   break;
               }
               for(var i = 0; i < referencedBy.length; i++)
               {
                    var currentNode = referencedBy[i];
                    // [Name, City]
                    if(currentNode[1])
                    {
                        // Is a Location OR a Gate
                        if(registry.Cities[currentNode[1]].Locations.hasOwnProperty(currentNode[0]))
                        {
                            // Is a Location
                            var refNeighbours = registry.Cities[currentNode[1]].Locations[currentNode[0]].Neighbours;
                            for(var j = 0; j < refNeighbours.length; j++)
                            {
                                // [Name, distance, City]
                                if(refNeighbours[j][0] == aboutNode.Name && refNeighbours[j][2] == aboutNode.City)
                                {
                                    refNeighbours[j][0] = event.gui.getComponent(GUI.E_FName).getText();
                                    break;
                                }
                            }
                        }
                        else
                        {
                            // Is a Gate
                            var refNeighbours = registry.Cities[currentNode[1]].Gates[currentNode[0]].Neighbours;
                            for(var j = 0; j < refNeighbours.length; j++)
                            {
                                if(refNeighbours[j][0] == aboutNode.Name && refNeighbours[j][2] == aboutNode.City)
                                {
                                    refNeighbours[j][0] = event.gui.getComponent(GUI.E_FName).getText();
                                    break;
                                }
                            }
                        }
                    }
                    else
                    {
                        // Is a node
                        var refNeighbours = registry.Nodes[currentNode[0]].Neighbours;
                        for(var j = 0; j < refNeighbours.length; j++)
                        {
                            if(refNeighbours[j][0] == aboutNode.Name)
                            {
                                refNeighbours[j][0] = event.gui.getComponent(GUI.E_FName).getText();
                                break;
                            }
                        }
                    }
               }

               // #2
               if(aboutNode.Type == "Node")
               {
                    var neighbourList = registry.Nodes[aboutNode.Name].Neighbours;
               }
               else if(aboutNode.Type == "Location")
               {
                    var neighbourList = registry.Cities[aboutNode.City].Locations[aboutNode.Name].Neighbours;
               }
               else if(aboutNode.Type == "Gate")
               {
                    var neighbourList = registry.Cities[aboutNode.City].Gates[aboutNode.Name].Neighbours;
               }
               else
               {
                   event.player.message("Something has gone very wrong, aborting action!");
                   log("[ERR!] Tried to save name for node '" + aboutNode.Name + "' but it failed a check it previously passed! This is probably because I forgot to add a new node type to the list of checks in #2.");
                   break;
               }

               for(var i = 0; i < neighbourList.length; i++)
               {
                    var currentNode = neighbourList[i];
                    // [Name, Distance, City]
                    if(currentNode[2])
                    {
                        // Is a Location OR a Gate
                        if(registry.Cities[currentNode[2]].Locations.hasOwnProperty(currentNode[0]))
                        {
                            // Is a Location
                            var refNeighbours = registry.Cities[currentNode[2]].Locations[currentNode[0]].Refs;
                            for(var j = 0; j < refNeighbours.length; j++)
                            {
                                // [Name, City]
                                if(refNeighbours[j][0] == aboutNode.Name && refNeighbours[j][1] == aboutNode.City)
                                {
                                    refNeighbours[j][0] = event.gui.getComponent(GUI.E_FName).getText();
                                    break;
                                }
                            }
                        }
                        else
                        {
                            // Is a Gate
                            var refNeighbours = registry.Cities[currentNode[2]].Gates[currentNode[0]].Refs;
                            for(var j = 0; j < refNeighbours.length; j++)
                            {
                                if(refNeighbours[j][0] == aboutNode.Name && refNeighbours[j][1] == aboutNode.City)
                                {
                                    refNeighbours[j][0] = event.gui.getComponent(GUI.E_FName).getText();
                                    break;
                                }
                            }
                        }
                    }
                    else
                    {
                        // Is a node
                        var refNeighbours = registry.Nodes[currentNode[0]].Refs;
                        for(var j = 0; j < refNeighbours.length; j++)
                        {
                            if(refNeighbours[j][0] == aboutNode.Name && refNeighbours[j][1] == aboutNode.City)
                            {
                                refNeighbours[j][0] = event.gui.getComponent(GUI.E_FName).getText();
                                break;
                            }
                        }
                    }
               }

               // #3
               if(aboutNode.Type == "Node")
               {
                    registry.Nodes[event.gui.getComponent(GUI.E_FName).getText()] = JSON.parse(JSON.stringify(registry.Nodes[aboutNode.Name])); // Duplicate data into new key
                    delete registry.Nodes[aboutNode.Name]; // Remove old data and old key
               }
               else if(aboutNode.Type == "Location")
               {
                    registry.Cities[aboutNode.City].Locations[event.gui.getComponent(GUI.E_FName).getText()] = JSON.parse(JSON.stringify(registry.Cities[aboutNode.City].Locations[aboutNode.Name]));
                    registry.Cities[aboutNode.City].Locations[event.gui.getComponent(GUI.E_FName).getText()].Name = event.gui.getComponent(GUI.E_FName).getText();
                    delete registry.Cities[aboutNode.City].Locations[aboutNode.Name];
               }
               else if(aboutNode.Type == "Gate")
               {
                registry.Cities[aboutNode.City].Gates[event.gui.getComponent(GUI.E_FName).getText()] = JSON.parse(JSON.stringify(registry.Cities[aboutNode.City].Gates[aboutNode.Name]));
                registry.Cities[aboutNode.City].Gates[event.gui.getComponent(GUI.E_FName).getText()].Name = event.gui.getComponent(GUI.E_FName).getText();
                delete registry.Cities[aboutNode.City].Gates[aboutNode.Name];
               }

               // Save registry
               event.player.world.getStoreddata().put("NodeRegistry", JSON.stringify(registry));
               // Save data to block
               aboutNode.Name = event.gui.getComponent(GUI.E_FName);
               block.getStoreddata().put("about", JSON.stringify(aboutNode));

               madeChanges = true;
            }
            // TODO If City change (copypaste from above)
            if(event.gui.getComponent(GUI.E_FCity).getText() != aboutNode.City)
            {
                /* edit neighbour entries first
                    Neighbour Refs must be changed
                Change name in registry and about
                */
               var registry = event.player.world.getTempdata().get("NodeRegistry");
               if(aboutNode.Type == "Node")
               {
                    var referencedBy = registry.Nodes[aboutNode.Name].Refs;
               }
               else if(aboutNode.Type == "Location")
               {
                    var referencedBy = registry.Cities[aboutNode.City].Locations[aboutNode.Name].Refs;
               }
               else if(aboutNode.Type == "Gate")
               {
                    var referencedBy = registry.Cities[aboutNode.City].Gates[aboutNode.Name].Refs;
               }
               else
               {
                   event.player.message("Something has gone very wrong, aborting action!");
                   log("[ERR!] Tried to save City for node '" + aboutNode.Name + "' but it had no valid type!");
                   break;
               }
               for(var i = 0; i < referencedBy.length; i++)
               {
                    var currentNode = referencedBy[i];
                    // [Name, City]
                    if(currentNode[1])
                    {
                        // Is a Location OR a Gate
                        if(registry.Cities[currentNode[1]].Locations.hasOwnProperty(currentNode[0]))
                        {
                            // Is a Location
                            var refNeighbours = registry.Cities[currentNode[1]].Locations[currentNode[0]].Neighbours;
                            for(var j = 0; j < refNeighbours.length; j++)
                            {
                                // [Name, distance, City]
                                if(refNeighbours[j][0] == aboutNode.Name && refNeighbours[j][2] == aboutNode.City)
                                {
                                    refNeighbours[j][2] = event.gui.getComponent(GUI.E_FCity).getText();
                                    break;
                                }
                            }
                        }
                        else
                        {
                            // Is a Gate
                            var refNeighbours = registry.Cities[currentNode[1]].Gates[currentNode[0]].Neighbours;
                            for(var j = 0; j < refNeighbours.length; j++)
                            {
                                if(refNeighbours[j][0] == aboutNode.Name && refNeighbours[j][2] == aboutNode.City)
                                {
                                    refNeighbours[j][2] = event.gui.getComponent(GUI.E_FCity).getText();
                                    break;
                                }
                            }
                        }
                    }
                    else
                    {
                        // Is a node
                        event.player.message("Something has gone very wrong, aborting action!");
                        log("[ERR!] Tried to save City for node '" + aboutNode.Name + "' but it appears to be a node! Nodes must be stateless! (do not belong to a City)");
                        break;
                    }
               }

               // #2
               if(aboutNode.Type == "Node")
               {
                    event.player.message("Something has gone very wrong, aborting action!");
                    log("[ERR!] Tried to save City for node '" + aboutNode.Name + "' but it appears to be a node! Nodes must be stateless! (do not belong to a City)");
                    break;
                }
               else if(aboutNode.Type == "Location")
               {
                    var neighbourList = registry.Cities[aboutNode.City].Locations[aboutNode.Name].Neighbours;
               }
               else if(aboutNode.Type == "Gate")
               {
                    var neighbourList = registry.Cities[aboutNode.City].Gates[aboutNode.Name].Neighbours;
               }
               else
               {
                   event.player.message("Something has gone very wrong, aborting action!");
                   log("[ERR!] Tried to save City for node '" + aboutNode.Name + "' but it failed a check it previously passed! This is probably because I forgot to add a new node type to the list of checks in #2.");
                   break;
               }

               for(var i = 0; i < neighbourList.length; i++)
               {
                    var currentNode = neighbourList[i];
                    // [Name, Distance, City]
                    if(currentNode[2])
                    {
                        // Is a Location OR a Gate
                        if(registry.Cities[currentNode[2]].Locations.hasOwnProperty(currentNode[0]))
                        {
                            // Is a Location
                            var refNeighbours = registry.Cities[currentNode[2]].Locations[currentNode[0]].Refs;
                            for(var j = 0; j < refNeighbours.length; j++)
                            {
                                // [Name, City]
                                if(refNeighbours[j][0] == aboutNode.Name && refNeighbours[j][1] == aboutNode.City)
                                {
                                    refNeighbours[j][1] = event.gui.getComponent(GUI.E_FCity).getText();
                                    break;
                                }
                            }
                        }
                        else
                        {
                            // Is a Gate
                            var refNeighbours = registry.Cities[currentNode[2]].Gates[currentNode[0]].Refs;
                            for(var j = 0; j < refNeighbours.length; j++)
                            {
                                if(refNeighbours[j][0] == aboutNode.Name && refNeighbours[j][1] == aboutNode.City)
                                {
                                    refNeighbours[j][1] = event.gui.getComponent(GUI.E_FCity).getText();
                                    break;
                                }
                            }
                        }
                    }
                    else
                    {
                        // Is a node
                        event.player.message("Something has gone very wrong, aborting action!");
                        log("[ERR!] Tried to save City for node '" + aboutNode.Name + "' but it appears to be a node! Nodes must be stateless! (do not belong to a City)");
                        break;
                    }
               }

               // #3
               if(aboutNode.Type == "Node")
               {
                    event.player.message("Something has gone very wrong, aborting action!");
                    log("[ERR!] Tried to save City for node '" + aboutNode.Name + "' but it appears to be a node! Nodes must be stateless! (do not belong to a City)");
                    break;
               }
               else if(aboutNode.Type == "Location")
               {
                    registry.Cities[event.gui.getComponent(GUI.E_FCity).getText()].Locations[aboutNode.Name] = JSON.parse(JSON.stringify(registry.Cities[aboutNode.City].Locations[aboutNode.Name]));
                    registry.Cities[event.gui.getComponent(GUI.E_FCity).getText()].Locations[aboutNode.Name].City = event.gui.getComponent(GUI.E_FCity).getText();
                    delete registry.Cities[aboutNode.City].Locations[aboutNode.Name];
               }
               else if(aboutNode.Type == "Gate")
               {
                    registry.Cities[event.gui.getComponent(GUI.E_FCity).getText()].Gates[aboutNode.Name] = JSON.parse(JSON.stringify(registry.Cities[aboutNode.City].Gates[aboutNode.Name]));
                    registry.Cities[event.gui.getComponent(GUI.E_FCity).getText()].Gates[aboutNode.Name].City = event.gui.getComponent(GUI.E_FCity).getText();
                    delete registry.Cities[aboutNode.City].Gates[aboutNode.Name];
               }

               // Save registry
               event.player.world.getStoreddata().put("NodeRegistry", JSON.stringify(registry));
               // Save data to block
               aboutNode.City = event.gui.getComponent(GUI.E_FCity);
               block.getStoreddata().put("about", JSON.stringify(aboutNode));

               madeChanges = true;
            }
            // Confirm to player
            break;
        case GUI.E_BEditNeighbours: // Opens Edit Neighbour GUI
            var posLabelText = event.gui.getComponent(GUI.E_LCords).getText();
            // X = index of X+2:index of Y-1
            // Y = index of Y+2:index of Z-1
            // Z = index of Z+2
            var posX = posLabelText.slice(posLabelText.indexOf("X")+2,posLabelText.indexOf("Y")-1);
            var posY = posLabelText.slice(posLabelText.indexOf("Y")+2,posLabelText.indexOf("Z")-1);
            var posZ = posLabelText.slice(posLabelText.indexOf("Z")+2);

            var pos = event.player.world.getBlock(posX, posY, posZ).getPos();
            openEditNeighbourGUI(event, pos);
            break;
        case GUI.E_BDeleteNode: // TODO Opens prompt to delete
            // Should ask for confirmation
            var confirmGui = event.API.createCustomGui(GUI.E_DeleteNodeConfirmation, 256, 80, true);
            confirmGui.setBackgroundTexture("customnpcs:textures/gui/bgfilled.png");
            confirmGui.addLabel(GUI.E_LTitle, "ARE YOU SURE?", 90, 15, 150, 10, 16711680);
            confirmGui.addLabel(GUI.E_LSubtitle, "This action will delete this node from the registry and references to in from other nodes. Block will be removed also.", 10, 20, 236, 40);
            confirmGui.addButton(GUI.E_BCancel, "Cancel", 10, 60, 50, 20);
            confirmGui.addButton(GUI.E_BConfirm, "Confirm", 196, 60, 50, 20);

            event.player.showCustomGui(confirmGui);
            break;
        case GUI.E_BConfirm: // TODO Deletes Node
            if(event.gui.getID() === GUI.E_DeleteNodeConfirmation)
            {

            }
            else if(event.gui.getID() === GUI.E_DeleteNeighbourConfirmation)
            {

            }
            break;
        case GUI.E_BCancel: // TODO Does not delete node, closes prompt and brings back the gui
            break;
        case GUI.EN_BRemoveNeighbour: // TODO Removes the neighbour, maybe a confirmation prompt?
            break;
        case GUI.EN_BBack: // TODO Returns to the Edit Gui
            break;
    }
    
}
function customGuiScroll(event)
{
    switch(event.scrollId)
    {
        case GUI.L_SCityList:
            event.gui.getComponent(GUI.L_FCity).setText(event.selection[0]);
            event.gui.update(event.player);
            break;
        case GUI.G_SCityList:
            event.gui.getComponent(GUI.G_FCity).setText(event.selection[0]);
            event.gui.update(event.player);
            break;
        case GUI.S_SModeList:
            var tool = event.player.getMainhandItem();
            var settings = tool.getTempdata().get("settings");

            settings.mode = event.selection[0];
            tool.getStoreddata().put("savedSettings", JSON.stringify(settings));

            updateItemDesc(tool, settings.mode);
            if(tool.getStoreddata().get("AnalysisSelectedNode"))
                {
                    var npcList = event.player.world.getNearbyEntities(event.player.getPos(), 42, 2);
                    for(var i = 0; i<npcList.length; i++)
                    {
                        if(npcList[i].hasTag("RoadsAnalysisWalker")){npcList[i].despawn();}
                    }
                }
                tool.getStoreddata().put("AnalysisSelectedNode", "");
            break;
        case GUI.E_SCityList:
            event.gui.getComponent(GUI.E_FCity).setText(event.selection[0]);
            event.gui.update(event.player);
            break;
    }
}

function enumerate(List, StartVal) // got tired of adding everything manually
{
    var enumeratedObject = {};
    for(var i = 0; i < List.length; i++)
    {
        enumeratedObject[List[i]] = i + StartVal;
    }
    return enumeratedObject;
}