/*
What this needs to do:
    - Place scripted blocks containing the right info on the floor where the player clicks
    - Register points in-between entry/exits
    - Edit nodes
    - Have an NPC to walk newly created paths
    - 

Modes:
    1. Creating Nodes
        1. Pathfinding nodes ("Road Nodes")
        2. Entry/exit nodes ("Locations")
        3. City entry/exit nodes ("Locations" when shift right clicking)
    2. Editing Nodes ("Editing")
    3. Analysis
        1. Have npc walk along created route
*/

var NpcAPI = Java.type("noppes.npcs.api.NpcAPI").Instance();
var File = Java.type("java.io.File");
var Files = Java.type("java.nio.file.Files");
var CHARSET_UTF_8 = Java.type("java.nio.charset.StandardCharsets").UTF_8;

var modeInfo = { // Descriptions for what each mode does, there's probably a better way
    "None":"Used to aid creation of rode network.",
    "Locations":"Creates locations where clicked. Shift + Left Click to place a city entry/exit node.",
    "Road Nodes":"Used to create a path between two locations. Shift + Left Click to place and intersection.",
    "Editing":"Edit existing nodes.",
    "Analysis":"Debug the roads you have placed down."
};
var defaultRegistry = {
    "Info":
    {
        "Version": 2,
        "World": "World Name",
        "NumLocations": 0,
        "NumGates": 0,
        "NumNodes": 0,
        "LockedBy": "",
        "Desc": "This was generated by RoadMaker Helper, you can change this line if you want."
    },
    "Cities":
    {
        "World":
        {
            "Locations":{},
            "Gates":{}
        }
    },
    "Nodes":
    {

    }
};
var defaultSettings = {
    "allowBacktrack": false, // Allow travel in two directions
    "mode": "None",
    "lockRegistry": true, // TODO Prevent race-condition by only allowing 1 editor at a time
    "autoUpdateFile": true // Should the saved file be updated upon every node's creation?
};

var GUI = { // NodeType_TypeName eg L_FName is Location_TextFieldName 
    "L_Title":1,
    "L_FName":2,
    "L_LName":3,
    "L_FCity":4,
    "L_LCity":5,
    "L_SCityList":6,
    "L_LLocation":7,
    "L_LCords":8,
    "L_BCancel":9,
    "L_BSave":10,

    "G_LTitle":11,
    "G_LCity":12,
    "G_FCity":13,
    "G_SCityList":14,
    "G_LType":15,
    "G_BChangeType":16,
    "G_LLocation":27,
    "G_LCords":28,
    "G_BCancel":17,
    "G_BSave":18,

    "S_LTitle":19,
    "S_LBacktrack":20,
    "S_BBacktrack":21,
    "S_LRegistryLock":22,
    "S_BRegistryLock":23,
    "S_LAutoSave":24,
    "S_BAutosave":25,
    "S_BSaveNow":26,
    "S_LFileOps":29,
    "S_BOverwriteRegistry":30,
    "S_BImportMapData":31,
    "S_BClearRegistry":32,
    "S_LOther":33,
    "S_BClearPrevNode":34,
    "S_BResetSettings":35,
    "S_BClose":36,
    "S_LMode":37,
    "S_SModeList":38,
    "S_BConfirm":39,
    "S_BCancel":40
}

function init(event)
{
    // This keeps getting smaller
    var item = event.item;
    
    //if(!item.getStoreddata().get("currentMode")){item.getStoreddata().put("currentMode", "None");} // First init, set mode to none
    if(!item.getStoreddata().get("savedSettings")){item.getStoreddata().put("savedSettings", JSON.stringify(defaultSettings));item.getTempdata().put("settings", JSON.parse(JSON.stringify(defaultSettings)));} //Save settings
    else{item.getTempdata().put("settings", JSON.parse(item.getStoreddata().get("savedSettings")));} // Retreive settings

    var settings = item.getTempdata().get("settings");
    var savedMode = settings.mode; // Retrieve mode name
    updateItemDesc(item, savedMode);
    /*item.setDurabilityShow(false); // Hide durability bar
    item.setColor(12465151); // #BE33FF aka purpleish
    item.setCustomName("Road Maker: §6" + savedMode);
    item.setLore(["§2Current Mode: §6" + savedMode, "§a[shift + left click] air to change mode", modeInfo[savedMode]]);
    item.setStackSize(1); // There should never be two of these but if that happens, you have to choose one*/

    var world = NpcAPI.getIWorld(0);
    if(!world.getTempdata().get("NodeRegistry") && !world.getStoreddata().get("NodeRegistry"))
    {
        var roadsFolder = new File("saves/" + world.getName());
        var registryFile = new File("saves/" + world.getName() + "/Roads/Node Registry.json");
        if(registryFile.exists())
        {
            var fileContents = Files.readAllLines(registryFile.toPath(), CHARSET_UTF_8)[0];
            var registry = JSON.parse(fileContents);
            world.getStoreddata().put("NodeRegistry", fileContents);
            world.getTempdata().put("NodeRegistry", registry)
        }
        else
        {
            roadsFolder.mkdirs();
            registryFile.createNewFile();
            defaultRegistry["Info"]["World"] = world.getName();
            Files.write(registryFile.toPath(), JSON.stringify(defaultRegistry).getBytes());
            world.getTempdata().put("NodeRegistry", defaultRegistry)
            world.getStoreddata().put("NodeRegistry", JSON.stringify(defaultRegistry));
        }
    }
    else{world.getTempdata().put("NodeRegistry", JSON.parse(world.getStoreddata().get("NodeRegistry")));}
}

function updateItemDesc(Item, NewMode)
{
    Item.setDurabilityShow(false); // Hide durability bar
    Item.setColor(12465151); // #BE33FF aka purpleish
    Item.setCustomName("Road Maker: §6" + NewMode);
    Item.setLore(["§2Current Mode: §6" + NewMode, "§a[shift + left click] air to change mode", modeInfo[NewMode]+"\n§6prevNode: §a" + function(val){if(val){return "§2"+val.Name;}else{return "§4Not Set";}}(Item.getTempdata().get("prevNode"))]);
    Item.setStackSize(1); // There should never be two of these but if that happens, you have to choose one
}

/* sadly shift right clicking in cretive opens the item's script interface, moving to attack event
function interact(event)
{
    // 0:air, 1:entity, 2:block
    switch(event.type)
    {
        case 0:
            // Player clicked on the air
            event.player.message("Type is air");
            //event.item.getStoreddata().put("currentMode", "None");
            if(event.player.isSneaking())
            {
                var savedMode = event.item.getStoreddata().get("currentMode");
                var modeList = Object.keys(modeInfo);
                //modeList.indexOf(savedMode) + 1
                if(modeList.indexOf(savedMode) + 1 == modeList.length)
                {
                    var newIndex = 0;
                }
                else
                {
                    var newIndex = modeList.indexOf(savedMode) + 1;
                }
                event.item.getStoreddata().put("currentMode", modeList[newIndex]);
                savedMode = event.item.getStoreddata().get("currentMode");
                event.item.setCustomName("Road Maker: §6" + savedMode);
                event.item.setLore(["§2Current Mode: §6" + savedMode, "§a[shift + right click] to change mode", modeInfo[savedMode]]);
            }
            //event.setCanceled(true); no work ;(
            break;
        case 1:
            // Player clicked on an entity
            event.player.message("Type is entity");
            break;
        case 2:
            // Player clicked on a block
            event.player.message("Type is block");
            var pos = event.target.getPos();
            var newBlock = event.player.world.getBlock(pos.getX(), pos.getY() + 1, pos.getZ());
            //newBlock.setBlock("minecraft:glass");
            newBlock.setBlock("customnpcs:npcscripted");
            newBlock = event.player.world.getBlock(pos.getX(), pos.getY() + 1, pos.getZ());
            //event.player.message(newBlock.getTileEntityNBT().getCompound("Scripts").getKeys()); fail

            newBlock.executeCommand​('blockdata ~ ~ ~ {Scripts:[{Script:"function init(event){event.block.setModel(\"minecraft:glass\");}",Console:[],ScriptList:[]}]}');

            break;
    }
}
*/

function attack(event)
{
    // 0:air, 1:entity, 2:block
    switch(event.type)
    {
        case 0:
            // Player clicked on the air
            // Only change mode if the player is sneaking
            if(event.player.isSneaking())
            {
                var settings = event.item.getTempdata().get("settings");
                var savedMode = settings.mode; // Retrieve mode name
                var modeList = Object.keys(modeInfo); // Get an ordered list of all modes
                // Find the index of the current mode and move to the next. If it is the last element, go back to the first
                if(modeList.indexOf(savedMode) + 1 == modeList.length){var newIndex = 0;}
                else{var newIndex = modeList.indexOf(savedMode) + 1;}
                
                settings.mode = modeList[newIndex];
                event.item.getTempdata().put("settings", settings); // Save new mode
                event.item.getStoreddata().put("savedSettings", JSON.stringify(settings));
                updateItemDesc(event.item, settings.mode);
            }
            else{openSettingsGUI(event, event.item);}
            break;
        case 1:
            // Player clicked on an entity
            // TODO make this interact with the npc somehow
            event.player.message("That is an entity");
            break;
        case 2:
            // Player clicked on a block
            var pos = event.target.getPos().add(0,1,0);
            var currentMode = event.item.getTempdata().get("settings")["mode"];

            if(currentMode == "None")
            {
                event.player.message("No mode set, doing nothing");
            }
            else if(currentMode == "Locations")
            { // Placing location or city entry/exit
                if(!event.player.isSneaking())
                { // Player is placing a location block
                    openLocationGUI(event, pos);
                }
                else
                { // Player is placing a city entry/exit block
                    openGateGUI(event, pos);
                }
            }
            else if(currentMode == "Road Nodes") // Placing node or intersection
            {
                var block = event.player.world.getBlock(pos.getX(), pos.getY()-1, pos.getZ());
                if(block.getStoreddata().get("about"))
                {
                    // Block is a scripted block, possibly made with this script. Check type
                    var blockInfo = JSON.parse(block.getStoreddata().get("about"));
                    if(blockInfo.hasOwnProperty("Type"))
                    {
                        var blockType = blockInfo["Type"];
                        if(blockType == "Node" || blockType == "Location" || blockType == "Gate")
                        {
                            // Is part of the road network
                            // If no previous node: Set as previous node
                            // Else if previous node, set as a neighbour and then set to the previous node
                            var prevNode = event.item.getTempdata().get("prevNode");
                            if(prevNode != null && prevNode["Name"] != blockInfo["Name"])
                            {
                                // There was a previous node and this is not it
                                // Set this node as a neighbour to the previous node
                                // Then set this node as the previous node
                                var registry = event.player.world.getTempdata().get("NodeRegistry"); // Get node registry
                                var settings = event.item.getTempdata().get("settings");
                                // Setting node as neighbour
                                updateRefsAndNeighbours(event.player, registry, settings, prevNode, blockInfo, pos);
                                // This is now the previous Node
                                event.item.getTempdata().put("prevNode", blockInfo);
                                event.player.message("Set Node " + blockInfo["Name"] + " as a neighbour of " + prevNode["Name"]);
                            }
                            else if(prevNode != null && prevNode["Name"] == blockInfo["Name"])
                            {
                                // There was a previous node and, it itself, has been clicked
                                // Tell the player to click something else
                                event.player.message("This Node is already set as the previous node, place a new Node or select an existing node to add a path from this Node.");
                            }
                            else
                            {
                                // There is no previous node, this shouldn't happen unless the player relogs
                                // Set this node as previous node
                                event.item.getTempdata().put("prevNode", blockInfo);
                                event.player.message("Set " + JSON.stringify(blockInfo) + " as previous node");
                            }
                            updateItemDesc(event.item, currentMode);
                        }else{event.player.message("No matching type for scripted block");if(event.player.isSneaking()){placeBlock(event.player, pos, "Intersection");}else{placeBlock(event.player, pos, "Node");}}

                    }else{event.player.message("No Type for scripted block");if(event.player.isSneaking()){placeBlock(event.player, pos, "Intersection");}else{placeBlock(event.player, pos, "Node");}}
                }else{event.player.message("No about for scripted block");if(event.player.isSneaking()){placeBlock(event.player, pos, "Intersection");}else{placeBlock(event.player, pos, "Node");}}
            }
            else if(currentMode == "Editing") // TODO Editing mode
            {
                event.player.message("Write code to edit nodes here!");
            }
            else if(currentMode == "Analysis") // TODO Analysis mode
            {
                event.player.message("Write code for analysis here!");
            }
            else
            {
                event.player.message("You are in the darkest timeline and evil Abed has stolen this mode!");
            }

            
            break;
        default:
            event.player.message("Unexpected event type! Expected range 0-2 but got " + event.type);
    }
    event.setCanceled(true);
}

function placeBlock(Player, Pos, Type, Gui)
{
    Gui = Gui || null;
    // Set appropriate values
    var registry = Player.world.getTempdata().get("NodeRegistry"); // Get node registry
    var tool = Player.getMainhandItem();
    var settings = tool.getTempdata().get("settings");
    // TODO Update scripts here
    if(Type === "Node") 
    {
        // Regular node
        var nodeType = Type;
        var colour = 0;
        var City = null;
        var nodeInfo = {"isIntersection":false,"Pos":[Pos.getX(),Pos.getY(),Pos.getZ()],"Neighbours":[],"Refs":[]};
        registry["Info"]["NumNodes"] ++; // Incrememnt number of nodes
        var nodeName = "n" + (registry["Info"]["NumNodes"]); // Node name is "n" with the number of nodes appended to it
        var stringInfo = JSON.stringify(nodeInfo).replace(/"/g, "" ).replace(/ /g, "").replace(/\n/g, "");
        var script = 'ScriptLanguage:"ECMAScript",ScriptEnabled:1b,Scripts:[{Script:"//' + stringInfo + '",Console:[],ScriptList:[]}]';
    }
    else if(Type === "Intersection")
    { // Intersection node
        var nodeType = "Node";
        var colour = 3;
        var City = null;
        var nodeInfo = {"isIntersection":true,"Pos":[Pos.getX(),Pos.getY(),Pos.getZ()],"Neighbours":[],"Refs":[]};
        registry["Info"]["NumNodes"] ++; // Incrememnt number of nodes
        var nodeName = "n" + (registry["Info"]["NumNodes"]); // Node name is "n" with the number of nodes appended to it
        var stringInfo = JSON.stringify(nodeInfo).replace(/"/g, "" ).replace(/ /g, "").replace(/\n/g, "");
        var script = 'ScriptLanguage:"ECMAScript",ScriptEnabled:1b,Scripts:[{Script:"//' + stringInfo + '",Console:[],ScriptList:[]}]';
    }
    else if(Type === "Location")
    {// Location block
        var nodeType = Type;
        var colour = 1;
        var Name = Gui.getComponent(GUI.L_FName).getText();
        var City = Gui.getComponent(GUI.L_FCity).getText();
        var nodeInfo = {"Pos":[Pos.getX(),Pos.getY(),Pos.getZ()],"Neighbours":[],"Refs":[],"City":City,"Name":Name};
        var nodeName = Name;
        registry["Info"]["NumLocations"] ++; // Incrememnt number of locations
        var stringInfo = JSON.stringify(nodeInfo).replace(/"/g, "" ).replace(/ /g, "").replace(/\n/g, "");
        var script = 'ScriptLanguage:"ECMAScript",ScriptEnabled:1b,Scripts:[{Script:"//' + stringInfo + '",Console:[],ScriptList:[]}]';
    }
    else if(Type === "Gate")
    { // Gate node
        var nodeType = Type;
        var colour = 5;
        var City = Gui.getComponent(GUI.G_FCity).getText();
        var gateType = Gui.getComponent(GUI.G_BChangeType).getLabel();
        registry["Info"]["NumGates"] ++; // Incrememnt number of gates
        var nodeName = "G" + (registry["Info"]["NumGates"]); // Gate name is "G" with the number of gates appended to it
        var nodeInfo = {"Type":gateType,"Pos":[Pos.getX(),Pos.getY(),Pos.getZ()],"Neighbours":[],"Refs":[],"City":City};
        var stringInfo = JSON.stringify(nodeInfo).replace(/"/g, "" ).replace(/ /g, "").replace(/\n/g, "");
        var script = 'ScriptLanguage:"ECMAScript",ScriptEnabled:1b,Scripts:[{Script:"//' + stringInfo + '",Console:[],ScriptList:[]}]';
    }
    else
    {
        log("[ERR] placeBlock failed! Type was not 'Node', 'Intersection', 'Location' or 'Gate'. Was: '"+Type+"'");
        Player.message("[ERR] placeBlock failed! Type was not 'Node', 'Intersection', 'Location' or 'Gate'. Was: '"+Type+"'");
        return false;
    }
    
    // Create block
    var newBlock = Player.world.getBlock(Pos.getX(), Pos.getY(), Pos.getZ());
    newBlock.setBlock("customnpcs:npcscripted");
    newBlock = Player.world.getBlock(Pos.getX(), Pos.getY(), Pos.getZ());
    newBlock.setModel(newBlock.world.createItem("minecraft:stained_glass", colour, 1));
    newBlock.setIsPassible(true);
    newBlock.getTextPlane().setText(nodeName);
    newBlock.getTextPlane().setScale(2);
    newBlock.getTextPlane2().setRotationY(0);
    newBlock.getTextPlane2().setText(nodeName);
    newBlock.getTextPlane2().setScale(2);
    newBlock.getTextPlane2().setRotationY(90);
    newBlock.getTextPlane3().setText(nodeName);
    newBlock.getTextPlane3().setScale(2);
    newBlock.getTextPlane3().setRotationY(180);
    newBlock.getTextPlane4().setText(nodeName);
    newBlock.getTextPlane4().setScale(2);
    newBlock.getTextPlane4().setRotationY(270);
    // Apply Script
    newBlock.executeCommand​('blockdata ~ ~ ~ {' + script + '}');
    newBlock.getStoreddata().put("about",JSON.stringify({"Type":nodeType, "Name":nodeName, "City":City})); // Make it easier to identify itself later
    Player.message("Placed node: " + newBlock.getStoreddata().get("about"));// nodeName

    // Register node
    if(nodeType === "Node"){registry["Nodes"][nodeName] = nodeInfo;} // Add nodeInfo under the name of the node
    else if(nodeType === "Location"){
        if(!registry.Cities.hasOwnProperty(City)){registry["Cities"][City] = {"Locations":{},"Gates":{}};} // Adds the City if it doesn't exist
        registry["Cities"][City]["Locations"][nodeName] = nodeInfo;} // Add nodeInfo under the name of the location
    else{if(!registry.Cities.hasOwnProperty(City)){registry["Cities"][City] = {"Locations":{},"Gates":{}};}registry["Cities"][City]["Gates"][nodeName] = nodeInfo;} // Add nodeInfo under the name of the gate
    
    // Update previous node and this one if backtracking
    var prevNode = tool.getTempdata().get("prevNode");
    // Only doing this for nodes, this will get called later when the node is linked to the Location or Gate
    if(prevNode && nodeType == "Node"){updateRefsAndNeighbours(Player, registry, settings, prevNode, {"Type":nodeType, "Name":nodeName, "City":City}, Pos);}

    // This is now the previous Node
    var about = {"Type":nodeType, "Name":nodeName, "City":City};
    tool.getTempdata().put("prevNode",about);
    
    // Save registry
    newBlock.world.getStoreddata().put("NodeRegistry", JSON.stringify(registry)); // Save the registry to storeddata

    // Save to file?
    if(settings.autoUpdateFile)
    {
        var registryFile = new File("saves/" + Player.world.getName() + "/Roads/Node Registry.json");
        Files.write(registryFile.toPath(), JSON.stringify(registry).getBytes());
    }

    updateItemDesc(tool, settings.mode);
    return newBlock;
}
function updateRefsAndNeighbours(Player, registry, settings, prevNode, nextNode, nextNodePos)
{
    // Add node as a refrence
    // Update new node first
    if(nextNode.Type == "Node"){registry["Nodes"][nextNode.Name]["Refs"].push([prevNode.Name, prevNode.City]);} // [Referenced by, City of node]
    else if(nextNode.Type == "Location"){registry["Cities"][nextNode.City]["Locations"][nextNode.Name]["Refs"].push([prevNode.Name, prevNode.City]);}
    else{registry["Cities"][nextNode.City]["Gates"][nextNode.Name]["Refs"].push([prevNode.Name, prevNode.City]);}
    // Find distance
    if(prevNode.Type == "Node"){var pPos = registry["Nodes"][prevNode.Name]["Pos"];}
    else if(prevNode.Type == "Location"){var pPos = registry["Cities"][prevNode.City]["Locations"][prevNode.Name]["Pos"];}
    else{var pPos = registry["Cities"][prevNode.City]["Gates"][prevNode.Name]["Pos"];}
    var neighbourPos = Player.world.getBlock(pPos[0], pPos[1], pPos[2]).getPos();
    var distance = nextNodePos.distanceTo(neighbourPos);
    // Update neighbour in previous node
    if(prevNode.Type == "Node"){registry["Nodes"][prevNode.Name]["Neighbours"].push([nextNode.Name, distance]);}
    else if(prevNode.Type == "Location"){registry["Cities"][prevNode.City]["Locations"][prevNode.Name]["Neighbours"].push([nextNode.Name, distance]);}
    else{registry["Cities"][prevNode.City]["Gates"][prevNode.Name]["Neighbours"].push([nextNode.Name, distance]);}

    if(settings.allowBacktrack)
    { // The previous node should be a neighbour of this node too
        // Update previous node first
        Player.message("Backtracking enabled")
        if(prevNode.Type == "Node"){registry["Nodes"][prevNode.Name]["Refs"].push([nextNode.Name, nextNode.City]);}
        else if(prevNode.Type == "Location"){registry["Cities"][prevNode.City]["Locations"][prevNode.Name]["Refs"].push([nextNode.Name, nextNode.City]);}
        else{registry["Cities"][prevNode.City]["Gates"][prevNode.Name]["Refs"].push([nextNode.Name, nextNode.City]);}
        // Update new node now
        if(nextNode.Type == "Node"){registry["Nodes"][nextNode.Name]["Neighbours"].push([prevNode.Name, distance]);}
        else if(nextNode.Type == "Location"){registry["Cities"][nextNode.City]["Locations"][nextNode.Name]["Neighbours"].push([prevNode.Name, distance]);}
        else{registry["Cities"][nextNode.City]["Gates"][nextNode.Name]["Neighbours"].push([prevNode.Name, distance]);}
    }
    return registry;
}

'Scripts:[{Script:"var test = true;",Console:[],ScriptList:[]}]'

function openLocationGUI(event, Pos) // Places Locations and Gates
{
    /* 
    If player is not sneaking: Place Location
        Open GUI
    Else player is sneaking: Place Gate
        Open GUI
    */
   var pauseGame = true;

    var gui = event.API.createCustomGui(0, 256, 256, pauseGame);
    gui.setBackgroundTexture("customnpcs:textures/gui/bgfilled.png");
    gui.addLabel(GUI.L_Title, "Location", 106, 15, 45, 1, 16747795); // 16747795 = #FF8D13 = orange

    gui.addTextField(GUI.L_FName, 40, 40, 100, 10);
    gui.addLabel(GUI.L_LName, "Name", 10, 40, 30, 10);
    gui.addTextField(GUI.L_FCity, 40, 60, 100, 10);
    gui.addLabel(GUI.L_LCity, "City", 10, 60, 30, 10);

    //var list = ["Option 1", "Option 2", "Option 3", "Option 4", "Option 5", "Option 6", "Option 7", "Option 8", "Option 9", "Option 10", "Option 11", "Option 12", "Option 13", "Option 14", "Option 15"];
    var registry = event.player.world.getTempdata().get("NodeRegistry"); // Get node registry
    var cityList = Object.keys(registry["Cities"]);
    gui.addScroll(GUI.L_SCityList, 40, 80, 100, 50, cityList);
    
    gui.addLabel(GUI.L_LLocation, "Location", 5, 150, 45, 10);
    gui.addLabel(GUI.L_LCords, "X:"+Pos.getX()+" Y:"+Pos.getY()+" Z:"+Pos.getZ(), 50, 150, 250, 10);
    
    gui.addButton(GUI.L_BCancel,"Cancel", 30, 200, 50, 20);
    gui.addButton(GUI.L_BSave,"Save", 150, 200, 50, 20);

    event.player.showCustomGui(gui);
}

function openGateGUI(event, Pos)
{
    var pauseGame = true;

    var gui = event.API.createCustomGui(0, 256, 256, pauseGame);
    gui.setBackgroundTexture("customnpcs:textures/gui/bgfilled.png");
    gui.addLabel(GUI.G_LTitle, "Gate", 106, 15, 45, 1, 1357312); // 1357312 = #14b600 = green

    gui.addTextField(GUI.G_FCity, 40, 40, 100, 10);
    gui.addLabel(GUI.G_LCity, "City", 10, 40, 30, 10);
    var registry = event.player.world.getTempdata().get("NodeRegistry"); // Get node registry
    var cityList = Object.keys(registry["Cities"]);
    gui.addScroll(GUI.G_SCityList, 40, 50, 100, 50, cityList);

    gui.addLabel(GUI.G_LType, "Type", 10, 110, 100, 10);
    gui.addButton(GUI.G_BChangeType,"Entry", 60, 110, 50, 20);

    gui.addLabel(GUI.G_LLocation, "Location", 5, 150, 45, 10);
    gui.addLabel(GUI.G_LCords, "X:"+Pos.getX()+" Y:"+Pos.getY()+" Z:"+Pos.getZ(), 50, 150, 250, 10);

    gui.addButton(GUI.G_BCancel,"Cancel", 30, 200, 50, 20);
    gui.addButton(GUI.G_BSave,"Save", 150, 200, 50, 20);

    event.player.showCustomGui(gui);
}

function openSettingsGUI(event, tool)
{
    var settings = tool.getTempdata().get("settings");
    var pauseGame = true;

    var gui = event.API.createCustomGui(0, 256, 256, pauseGame);
    gui.setBackgroundTexture("customnpcs:textures/gui/bgfilled.png");
    gui.addLabel(GUI.S_LTitle, "Settings", 106, 15, 45, 1);

    gui.addLabel(GUI.S_LBacktrack, "Allow Backtracking", 10, 40, 70, 20);
    gui.addButton(GUI.S_BBacktrack, function(val){if(val){return "§2"+val}else{return "§4"+val}}(settings.allowBacktrack), 80 ,40, 50, 20).setHoverText("Automatically allow travel in both directions.");
    gui.addLabel(GUI.S_LRegistryLock, "Lock Registry", 10, 60, 70, 20);
    gui.addButton(GUI.S_BRegistryLock, function(val){if(val){return "§2"+val}else{return "§4"+val}}(settings.lockRegistry), 80 ,60, 50, 20).setHoverText("Prevents a race condition\nby only allowing one\nplayer at a time to edit.");
    gui.addLabel(GUI.S_LAutoSave, "Automatically Write to File", 10, 80, 70, 20);
    gui.addButton(GUI.S_BAutosave, function(val){if(val){return "§2"+val}else{return "§4"+val}}(settings.autoUpdateFile), 80 ,80, 50, 20).setHoverText("Should the registry file be updated after every new node?\nDisable for larger networks and save manually.");
    gui.addLabel(GUI.S_LMode, "Mode", 40, 105, 70, 20);
    var modeList = Object.keys(modeInfo);
    gui.addScroll(GUI.S_SModeList, 10, 120, 100, 80, modeList).setDefaultSelection​(modeList.indexOf(settings.mode));

    gui.addLabel(GUI.S_LFileOps, "File Operations", 170, 40, 70, 20);
    gui.addButton(GUI.S_BSaveNow, "Write Now", 136, 60, 54, 20).setHoverText("All data is saved in game.\nThis button saves the data to the external file for processing.");
    gui.addButton(GUI.S_BImportMapData, "Import Map", 136, 80, 54, 20).setHoverText("Import Mapped Paths from file");
    gui.addButton(GUI.S_BOverwriteRegistry, "Overwrite", 190, 60, 54, 20).setHoverText("Import the registry file and overwrite the in-game registry");
    gui.addButton(GUI.S_BClearRegistry, "Purge", 190, 80, 54, 20).setHoverText("Clears the registry, removing all Locations, Gates and Nodes\n(Wipes all registry data)");

    gui.addLabel(GUI.S_LOther, "Other", 170, 105, 70, 20);
    gui.addButton(GUI.S_BClearPrevNode, "Clear prevNode", 140, 120, 100, 20).setHoverText("Removes prevNode so you can set it again to another node.");
    gui.addButton(GUI.S_BResetSettings, "Reset Settings", 140, 140, 100, 20).setHoverText("Resets all settings to default, does not delete the registry.");

    gui.addButton(GUI.S_BClose, "Close", 10, 210, 50, 20);

    event.player.showCustomGui(gui);
}

function editMode(event, Pos) // Manipulation of existing nodes
{
    return null;
}

function analysisMode(event, Pos) // Help debug issues
{
    return null;
}

function customGuiButton(event)
{
    //event.player.message("test");
    switch(event.buttonId)
    {
        case GUI.L_BCancel:
            event.player.closeGui();
            break;
        case GUI.L_BSave:
            //event.player.message(event.gui.getComponent(GUI.L_FName).getText() + "\n" + event.gui.getComponent(GUI.L_FCity).getText());
            // Need to get the pos
            var posLabelText = event.gui.getComponent(GUI.L_LCords).getText();
            // X = index of X+2:index of Y-1
            // Y = index of Y+2:index of Z-1
            // Z = index of Z+2
            var posX = posLabelText.slice(posLabelText.indexOf("X")+2,posLabelText.indexOf("Y")-1);
            var posY = posLabelText.slice(posLabelText.indexOf("Y")+2,posLabelText.indexOf("Z")-1);
            var posZ = posLabelText.slice(posLabelText.indexOf("Z")+2);

            var pos = event.player.world.getBlock(posX, posY, posZ).getPos();
            var newBlock = placeBlock(event.player, pos, "Location", event.gui);
            
            event.player.closeGui();
            break;
        case GUI.G_BChangeType:
            var button = event.gui.getComponent(GUI.G_BChangeType);
            if(button.getLabel() == "Entry"){button.setLabel("Exit");}
            else{button.setLabel("Entry");}
            //event.gui.updateComponent(button);
            event.gui.update(event.player);
            break;
        case GUI.G_BCancel:
            event.player.closeGui();
            break;
        case GUI.G_BSave:
            event.player.message("test")
            // Need to get the pos
            var posLabelText = event.gui.getComponent(GUI.G_LCords).getText();
            // X = index of X+2:index of Y-1
            // Y = index of Y+2:index of Z-1
            // Z = index of Z+2
            var posX = posLabelText.slice(posLabelText.indexOf("X")+2,posLabelText.indexOf("Y")-1);
            var posY = posLabelText.slice(posLabelText.indexOf("Y")+2,posLabelText.indexOf("Z")-1);
            var posZ = posLabelText.slice(posLabelText.indexOf("Z")+2);

            var pos = event.player.world.getBlock(posX, posY, posZ).getPos();
            var newBlock = placeBlock(event.player, pos, "Gate", event.gui);
            
            event.player.closeGui();
            break;
        case GUI.S_BBacktrack: // Toggle
            var tool = event.player.getMainhandItem();
            var settings = tool.getTempdata().get("settings");
            if(settings.allowBacktrack){settings.allowBacktrack = false;}
            else{settings.allowBacktrack = true;}
            tool.getStoreddata().put("savedSettings", settings);
            event.gui.getComponent(GUI.S_BBacktrack).setLabel(function(val){if(val){return "§2"+val}else{return "§4"+val}}(settings.allowBacktrack));
            event.gui.update(event.player);
            break;
        case GUI.S_BRegistryLock: // Toggle
            var tool = event.player.getMainhandItem();
            var settings = tool.getTempdata().get("settings");
            if(settings.lockRegistry){settings.lockRegistry = false;}
            else{settings.lockRegistry = true;}
            tool.getStoreddata().put("savedSettings", settings);
            event.gui.getComponent(GUI.S_BRegistryLock).setLabel(function(val){if(val){return "§2"+val}else{return "§4"+val}}(settings.lockRegistry));
            event.gui.update(event.player);
            break;
        case GUI.S_BAutosave: // Toggle
            var tool = event.player.getMainhandItem();
            var settings = tool.getTempdata().get("settings");
            if(settings.autoUpdateFile){settings.autoUpdateFile = false;}
            else{settings.autoUpdateFile = true;}
            tool.getStoreddata().put("savedSettings", settings);
            event.gui.getComponent(GUI.S_BAutosave).setLabel(function(val){if(val){return "§2"+val}else{return "§4"+val}}(settings.autoUpdateFile));
            event.gui.update(event.player);
            break;
        case GUI.S_BSaveNow:
            //var tool = event.player.getMainhandItem();
            var registry = event.player.world.getTempdata().get("NodeRegistry");
            var registryFile = new File("saves/" + event.player.world.getName() + "/Roads/Node Registry.json");
            Files.write(registryFile.toPath(), JSON.stringify(registry).getBytes());
            event.player.message("Saved Registry to external file: saves/" + event.player.world.getName() + "/Roads/Node Registry.json");
            break;
        case GUI.S_BOverwriteRegistry:
            // Should ask for confirmation
            var confirmGui = event.API.createCustomGui(1, 256, 80, true);
            confirmGui.setBackgroundTexture("customnpcs:textures/gui/bgfilled.png");
            confirmGui.addLabel(GUI.S_LTitle, "ARE YOU SURE?", 90, 15, 150, 10, 16711680);
            confirmGui.addLabel(GUI.S_LRegistryLock, "This action will overwrite all in-game data with data from the external file. The external file will not be erased.", 10, 20, 236, 40);
            confirmGui.addButton(GUI.S_BCancel, "Cancel", 10, 60, 50, 20);
            confirmGui.addButton(GUI.S_BConfirm, "Confirm", 196, 60, 50, 20);
            event.player.showCustomGui(confirmGui);
            break;
        case GUI.S_BImportMapData:
            var pathsFile = new File("saves/" + event.player.world.getName() + "/Roads/Mapped Paths.json");
            var fileContents = Files.readAllLines(pathsFile.toPath(), CHARSET_UTF_8)[0];
            var paths = JSON.parse(fileContents);
            event.player.world.getTempdata().put("MappedPaths", paths);
            event.player.world.getStoreddata().put("MappedPaths", fileContents);
            event.player.message("Done! Mapped Paths imported and ready for use!");
            break;
        case GUI.S_BClearRegistry:
            // Should ask for confirmation
            var confirmGui = event.API.createCustomGui(2, 256, 80, true);
            confirmGui.setBackgroundTexture("customnpcs:textures/gui/bgfilled.png");
            confirmGui.addLabel(GUI.S_LTitle, "ARE YOU SURE?", 90, 10, 150, 10, 16711680);
            confirmGui.addLabel(GUI.S_LRegistryLock, "This action will erase all registry data stored in-game. This will not erase any data in the external file or the physical nodes themselves.", 10, 20, 236, 40);
            confirmGui.addButton(GUI.S_BCancel, "Cancel", 10, 60, 50, 20);
            confirmGui.addButton(GUI.S_BConfirm, "Confirm", 196, 60, 50, 20);
            event.player.showCustomGui(confirmGui);
            break;
        case GUI.S_BClearPrevNode:
            var tool = event.player.getMainhandItem();
            tool.getTempdata().put("prevNode", "");
            updateItemDesc(tool, tool.getTempdata().get("settings").mode);
            event.player.message("prevNode cleared!");
            break;
        case GUI.S_BResetSettings:
            var tool = event.player.getMainhandItem();
            var settings = JSON.parse(JSON.stringify(defaultSettings)); // Need a separate object of defaultSettings will be edited :S
            tool.getTempdata().put("settings", settings);
            tool.getStoreddata().put("savedSettings", JSON.stringify(settings));
            event.gui.getComponent(GUI.S_BBacktrack).setLabel(function(val){if(val){return "§2"+val}else{return "§4"+val}}(settings.allowBacktrack));
            event.gui.getComponent(GUI.S_BRegistryLock).setLabel(function(val){if(val){return "§2"+val}else{return "§4"+val}}(settings.lockRegistry));
            event.gui.getComponent(GUI.S_BAutosave).setLabel(function(val){if(val){return "§2"+val}else{return "§4"+val}}(settings.autoUpdateFile));
            event.gui.update(event.player);
            event.player.message("Tool settings reset to default values");
            break;
        case GUI.S_BClose:
            event.player.closeGui();
            break;
        case GUI.S_BCancel:
            openSettingsGUI(event, event.player.getMainhandItem());
            break;
        case GUI.S_BConfirm:
            if(event.gui.getID() === 1) // Overwrite from file
            {
                var registryFile = new File("saves/" + event.player.world.getName() + "/Roads/Node Registry.json");
                var fileContents = Files.readAllLines(registryFile.toPath(), CHARSET_UTF_8)[0];
                var registry = JSON.parse(fileContents);
                event.player.world.getStoreddata().put("NodeRegistry", fileContents);
                event.player.world.getTempdata().put("NodeRegistry", registry);
                event.player.message("Done! Local data overwritten with external data.");
            }
            else if(event.gui.getID() === 2) // Purge local registry
            {
                event.player.world.getStoreddata().put("NodeRegistry", JSON.stringify(defaultRegistry));
                event.player.world.getTempdata().put("NodeRegistry", JSON.parse(JSON.stringify(defaultRegistry)));
                event.player.message("Done! Local data erased, blocks have not been removed. You should probably manually remove them.");
            }
            else{event.player.message("Somehow you've accidentally used GUI.S_BConfirm for something other than confirming a data overwrite or purge...")}
            break;
    }
    
}
function customGuiScroll(event)
{
    switch(event.scrollId)
    {
        case GUI.L_SCityList:
            event.gui.getComponent(GUI.L_FCity).setText(event.selection[0]);
            event.gui.update(event.player);
            break;
        case GUI.G_SCityList:
            event.gui.getComponent(GUI.G_FCity).setText(event.selection[0]);
            event.gui.update(event.player);
            break;
        case GUI.S_SModeList:
            var tool = event.player.getMainhandItem();
            var settings = tool.getTempdata().get("settings");

            settings.mode = event.selection[0];
            tool.getStoreddata().put("savedSettings", JSON.stringify(settings));

            updateItemDesc(tool, settings.mode);
            break;
    }
}